"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolkit = void 0;
const path = require("node:path");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const non_interactive_io_host_1 = require("./non-interactive-io-host");
const private_1 = require("./private");
const bootstrap_1 = require("../actions/bootstrap");
const deploy_1 = require("../actions/deploy");
const private_2 = require("../actions/deploy/private");
const private_3 = require("../actions/diff/private");
const private_4 = require("../actions/watch/private");
const cloud_assembly_1 = require("../api/cloud-assembly");
const private_5 = require("../api/cloud-assembly/private");
const private_6 = require("../api/io/private");
const shared_private_1 = require("../api/shared-private");
const util_1 = require("../private/util");
const concurrency_1 = require("../util/concurrency");
const promises_1 = require("../util/promises");
/**
 * The AWS CDK Programmatic Toolkit
 */
class Toolkit extends private_5.CloudAssemblySourceBuilder {
    props;
    /**
     * The toolkit stack name used for bootstrapping resources.
     */
    toolkitStackName;
    /**
     * The IoHost of this Toolkit
     */
    ioHost;
    /**
     * Cache of the internal SDK Provider instance
     */
    sdkProviderCache;
    constructor(props = {}) {
        super();
        this.props = props;
        this.toolkitStackName = props.toolkitStackName ?? shared_private_1.DEFAULT_TOOLKIT_STACK_NAME;
        let ioHost = props.ioHost ?? new non_interactive_io_host_1.NonInteractiveIoHost();
        if (props.emojis === false) {
            ioHost = (0, private_6.withoutEmojis)(ioHost);
        }
        if (props.color === false) {
            ioHost = (0, private_6.withoutColor)(ioHost);
        }
        // After removing emojis and color, we might end up with floating whitespace at either end of the message
        // This also removes newlines that we currently emit for CLI backwards compatibility.
        this.ioHost = (0, private_6.withTrimmedWhitespace)(ioHost);
    }
    /**
     * Access to the AWS SDK
     * @internal
     */
    async sdkProvider(action) {
        // @todo this needs to be different instance per action
        if (!this.sdkProviderCache) {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
            this.sdkProviderCache = await shared_private_1.SdkProvider.withAwsCliCompatibleDefaults({
                ...this.props.sdkConfig,
                ioHelper,
                logger: (0, private_6.asSdkLogger)(ioHelper),
            });
        }
        return this.sdkProviderCache;
    }
    /**
     * Helper to provide the CloudAssemblySourceBuilder with required toolkit services
     * @internal
     */
    async sourceBuilderServices() {
        return {
            ioHelper: (0, shared_private_1.asIoHelper)(this.ioHost, 'assembly'),
            sdkProvider: await this.sdkProvider('assembly'),
        };
    }
    /**
     * Bootstrap Action
     */
    async bootstrap(environments, options) {
        const startTime = Date.now();
        const results = [];
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'bootstrap');
        const bootstrapEnvironments = await environments.getEnvironments(this.ioHost);
        const source = options.source ?? bootstrap_1.BootstrapSource.default();
        const parameters = options.parameters;
        const bootstrapper = new shared_private_1.Bootstrapper(source, ioHelper);
        const sdkProvider = await this.sdkProvider('bootstrap');
        const limit = (0, concurrency_1.pLimit)(20);
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        await Promise.all(bootstrapEnvironments.map((environment, currentIdx) => limit(async () => {
            const bootstrapSpan = await ioHelper.span(private_6.SPAN.BOOTSTRAP_SINGLE)
                .begin(`${chalk.bold(environment.name)}: bootstrapping...`, {
                total: bootstrapEnvironments.length,
                current: currentIdx + 1,
                environment,
            });
            try {
                const bootstrapResult = await bootstrapper.bootstrapEnvironment(environment, sdkProvider, {
                    ...options,
                    toolkitStackName: this.toolkitStackName,
                    source,
                    parameters: parameters?.parameters,
                    usePreviousParameters: parameters?.keepExistingParameters,
                });
                const message = bootstrapResult.noOp
                    ? ` ✅  ${environment.name} (no changes)`
                    : ` ✅  ${environment.name}`;
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I9900.msg(chalk.green('\n' + message), { environment }));
                const envTime = await bootstrapSpan.end();
                const result = {
                    environment,
                    status: bootstrapResult.noOp ? 'no-op' : 'success',
                    duration: envTime.asMs,
                };
                results.push(result);
            }
            catch (e) {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E9900.msg(`\n ❌  ${chalk.bold(environment.name)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw e;
            }
        })));
        return {
            environments: results,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Synth Action
     */
    async synth(cx, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'synth');
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        const stacks = await assembly.selectStacksV2(selectStacks);
        const autoValidateStacks = options.validateStacks ? [assembly.selectStacksForValidation()] : [];
        await this.validateStacksMetadata(stacks.concat(...autoValidateStacks), ioHelper);
        await synthSpan.end();
        // if we have a single stack, print it to STDOUT
        const message = `Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`;
        const assemblyData = {
            assemblyDirectory: stacks.assembly.directory,
            stacksCount: stacks.stackCount,
            stackIds: stacks.hierarchicalIds,
        };
        if (stacks.stackCount === 1) {
            const firstStack = stacks.firstStack;
            const template = firstStack.template;
            const obscuredTemplate = (0, util_1.obscureTemplate)(template);
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I1901.msg(message, {
                ...assemblyData,
                stack: {
                    stackName: firstStack.stackName,
                    hierarchicalId: firstStack.hierarchicalId,
                    template,
                    stringifiedJson: (0, util_1.serializeStructure)(obscuredTemplate, true),
                    stringifiedYaml: (0, util_1.serializeStructure)(obscuredTemplate, false),
                },
            }));
        }
        else {
            // not outputting template to stdout, let's explain things to the user a little bit...
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I1902.msg(chalk.green(message), assemblyData));
            await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_INFO.msg(`Supply a stack id (${stacks.stackArtifacts.map((s) => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`));
        }
        return new private_5.IdentityCloudAssemblySource(assembly.assembly);
    }
    /**
     * Diff Action
     */
    async diff(cx, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'diff');
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        const stacks = await assembly.selectStacksV2(selectStacks);
        await synthSpan.end();
        const diffSpan = await ioHelper.span(private_6.SPAN.DIFF_STACK).begin({ stacks: selectStacks });
        const deployments = await this.deploymentsForAction('diff');
        const strict = !!options.strict;
        const contextLines = options.contextLines || 3;
        let diffs = 0;
        let formattedSecurityDiff = '';
        let formattedStackDiff = '';
        const templateInfos = await (0, private_3.makeTemplateInfos)(ioHelper, stacks, deployments, await this.sdkProvider('diff'), options);
        for (const templateInfo of templateInfos) {
            const formatter = new shared_private_1.DiffFormatter({
                ioHelper,
                templateInfo,
            });
            if (options.securityOnly) {
                const securityDiff = formatter.formatSecurityDiff({
                    requireApproval: shared_private_1.RequireApproval.BROADENING,
                });
                formattedSecurityDiff = securityDiff.formattedDiff ?? '';
                diffs = securityDiff.formattedDiff ? diffs + 1 : diffs;
            }
            else {
                const diff = formatter.formatStackDiff({
                    strict,
                    context: contextLines,
                });
                formattedStackDiff = diff.formattedDiff;
                diffs = diff.numStacksWithChanges;
            }
        }
        await diffSpan.end(`✨ Number of stacks with differences: ${diffs}`, {
            formattedSecurityDiff,
            formattedStackDiff,
        });
        return;
    }
    /**
     * List Action
     *
     * List selected stacks and their dependencies
     */
    async list(cx, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'list');
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        const stackCollection = await assembly.selectStacksV2(selectStacks);
        await synthSpan.end();
        const stacks = stackCollection.withDependencies();
        const message = stacks.map(s => s.id).join('\n');
        await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I2901.msg(message, { stacks }));
        return stacks;
    }
    /**
     * Deploy Action
     *
     * Deploys the selected stacks into an AWS account
     */
    async deploy(cx, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'deploy');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        return this._deploy(assembly, 'deploy', options);
    }
    /**
     * Helper to allow deploy being called as part of the watch action.
     */
    async _deploy(assembly, action, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stackCollection = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stackCollection, ioHelper);
        const synthDuration = await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stackCollection.stackCount === 0) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E5001.msg('This app contains no stacks'));
            return ret;
        }
        const deployments = await this.deploymentsForAction('deploy');
        const migrator = new shared_private_1.ResourceMigrator({ deployments, ioHelper });
        await migrator.tryMigrateResources(stackCollection, options);
        const parameterMap = (0, private_2.buildParameterMap)(options.parameters?.parameters);
        const hotswapMode = options.hotswap ?? shared_private_1.HotswapMode.FULL_DEPLOYMENT;
        if (hotswapMode !== shared_private_1.HotswapMode.FULL_DEPLOYMENT) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5400.msg([
                '⚠️ The --hotswap and --hotswap-fallback flags deliberately introduce CloudFormation drift to speed up deployments',
                '⚠️ They should only be used for development - never use them for your production Stacks!',
            ].join('\n')));
        }
        const stacks = stackCollection.stackArtifacts;
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        const buildAsset = async (assetNode) => {
            const buildAssetSpan = await ioHelper.span(private_6.SPAN.BUILD_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.buildSingleAsset(assetNode.assetManifestArtifact, assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
            });
            await buildAssetSpan.end();
        };
        const publishAsset = async (assetNode) => {
            const publishAssetSpan = await ioHelper.span(private_6.SPAN.PUBLISH_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.publishSingleAsset(assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
                forcePublish: options.forceAssetPublishing,
            });
            await publishAssetSpan.end();
        };
        const deployStack = async (stackNode) => {
            const stack = stackNode.stack;
            if (stackCollection.stackCount !== 1) {
                await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.bold(stack.displayName)));
            }
            if (!stack.environment) {
                throw new shared_private_1.ToolkitError(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            // The generated stack has no resources
            if (Object.keys(stack.template.Resources || {}).length === 0) {
                // stack is empty and doesn't exist => do nothing
                const stackExists = await deployments.stackExists({ stack });
                if (!stackExists) {
                    return ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5021.msg(`${chalk.bold(stack.displayName)}: stack has no resources, skipping deployment.`));
                }
                // stack is empty, but exists => delete
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5022.msg(`${chalk.bold(stack.displayName)}: stack has no resources, deleting existing stack.`));
                await this._destroy(assembly, 'deploy', {
                    stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                    roleArn: options.roleArn,
                });
                return;
            }
            const currentTemplate = await deployments.readCurrentTemplate(stack);
            const permissionChangeType = (0, private_3.determinePermissionType)(currentTemplate, stack);
            const deployMotivation = '"--require-approval" is enabled and stack includes security-sensitive updates.';
            const deployQuestion = `${deployMotivation}\nDo you wish to deploy these changes`;
            const deployConfirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5060.req(deployQuestion, {
                motivation: deployMotivation,
                concurrency,
                permissionChangeType,
            }));
            if (!deployConfirmed) {
                throw new shared_private_1.ToolkitError('Aborted by user');
            }
            // Following are the same semantics we apply with respect to Notification ARNs (dictated by the SDK)
            //
            //  - undefined  =>  cdk ignores it, as if it wasn't supported (allows external management).
            //  - []:        =>  cdk manages it, and the user wants to wipe it out.
            //  - ['arn-1']  =>  cdk manages it, and the user wants to set it to ['arn-1'].
            const notificationArns = (!!options.notificationArns || !!stack.notificationArns)
                ? (options.notificationArns ?? []).concat(stack.notificationArns ?? [])
                : undefined;
            for (const notificationArn of notificationArns ?? []) {
                if (!(0, util_1.validateSnsTopicArn)(notificationArn)) {
                    throw new shared_private_1.ToolkitError(`Notification arn ${notificationArn} is not a valid arn for an SNS topic`);
                }
            }
            const stackIndex = stacks.indexOf(stack) + 1;
            const deploySpan = await ioHelper.span(private_6.SPAN.DEPLOY_STACK)
                .begin(`${chalk.bold(stack.displayName)}: deploying... [${stackIndex}/${stackCollection.stackCount}]`, {
                total: stackCollection.stackCount,
                current: stackIndex,
                stack,
            });
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = (0, shared_private_1.tagsForStack)(stack);
            }
            let deployDuration;
            try {
                let deployResult;
                let rollback = options.rollback;
                let iteration = 0;
                while (!deployResult) {
                    if (++iteration > 2) {
                        throw new shared_private_1.ToolkitError('This loop should have stabilized in 2 iterations, but didn\'t. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose');
                    }
                    const r = await deployments.deployStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                        toolkitStackName: this.toolkitStackName,
                        reuseAssets: options.reuseAssets,
                        notificationArns,
                        tags,
                        deploymentMethod: options.deploymentMethod,
                        forceDeployment: options.forceDeployment,
                        parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                        usePreviousParameters: options.parameters?.keepExistingParameters,
                        rollback,
                        hotswap: hotswapMode,
                        extraUserAgent: options.extraUserAgent,
                        hotswapPropertyOverrides: options.hotswapProperties ? (0, private_2.createHotswapPropertyOverrides)(options.hotswapProperties) : undefined,
                        assetParallelism: options.assetParallelism,
                    });
                    switch (r.type) {
                        case 'did-deploy-stack':
                            deployResult = r;
                            break;
                        case 'failpaused-need-rollback-first': {
                            const motivation = r.reason === 'replacement'
                                ? `Stack is in a paused fail state (${r.status}) and change includes a replacement which cannot be deployed with "--no-rollback"`
                                : `Stack is in a paused fail state (${r.status}) and command line arguments do not include "--no-rollback"`;
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new shared_private_1.ToolkitError('Aborted by user');
                            }
                            // Perform a rollback
                            await this._rollback(assembly, action, {
                                stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                                orphanFailedResources: options.orphanFailedResourcesDuringRollback,
                            });
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        case 'replacement-requires-rollback': {
                            const motivation = 'Change includes a replacement which cannot be deployed with "--no-rollback"';
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new shared_private_1.ToolkitError('Aborted by user');
                            }
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        default:
                            throw new shared_private_1.ToolkitError(`Unexpected result type from deployStack: ${JSON.stringify(r)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose`);
                    }
                }
                const message = deployResult.noOp
                    ? ` ✅  ${stack.displayName} (no changes)`
                    : ` ✅  ${stack.displayName}`;
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5900.msg(chalk.green('\n' + message), deployResult));
                deployDuration = await deploySpan.timing(private_6.IO.CDK_TOOLKIT_I5000);
                if (Object.keys(deployResult.outputs).length > 0) {
                    const buffer = ['Outputs:'];
                    stackOutputs[stack.stackName] = deployResult.outputs;
                    for (const name of Object.keys(deployResult.outputs).sort()) {
                        const value = deployResult.outputs[name];
                        buffer.push(`${chalk.cyan(stack.id)}.${chalk.cyan(name)} = ${chalk.underline(chalk.cyan(value))}`);
                    }
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5901.msg(buffer.join('\n')));
                }
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5901.msg(`Stack ARN:\n${deployResult.stackArn}`));
                ret.stacks.push({
                    stackName: stack.stackName,
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackArn: deployResult.stackArn,
                    outputs: deployResult.outputs,
                    hierarchicalId: stack.hierarchicalId,
                });
            }
            catch (e) {
                // It has to be exactly this string because an integration test tests for
                // "bold(stackname) failed: ResourceNotReady: <error>"
                throw new shared_private_1.ToolkitError([`❌  ${chalk.bold(stack.stackName)} failed:`, ...(e.name ? [`${e.name}:`] : []), e.message].join(' '));
            }
            finally {
                if (options.traceLogs) {
                    // deploy calls that originate from watch will come with their own cloudWatchLogMonitor
                    const cloudWatchLogMonitor = options.cloudWatchLogMonitor ?? new shared_private_1.CloudWatchLogEventMonitor({ ioHelper });
                    const foundLogGroupsResult = await (0, shared_private_1.findCloudWatchLogGroups)(await this.sdkProvider('deploy'), ioHelper, stack);
                    cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5031.msg(`The following log groups are added: ${foundLogGroupsResult.logGroupNames}`));
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            const duration = synthDuration.asMs + (deployDuration?.asMs ?? 0);
            await deploySpan.end(`\n✨  Total time: ${(0, util_1.formatTime)(duration)}s\n`, { duration });
        };
        const assetBuildTime = options.assetBuildTime ?? deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const prebuildAssets = assetBuildTime === deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const concurrency = options.concurrency || 1;
        const stacksAndTheirAssetManifests = stacks.flatMap((stack) => [
            stack,
            ...stack.dependencies.filter(x => cxapi.AssetManifestArtifact.isAssetManifestArtifact(x)),
        ]);
        const workGraph = new shared_private_1.WorkGraphBuilder(ioHelper, prebuildAssets).build(stacksAndTheirAssetManifests);
        // Unless we are running with '--force', skip already published assets
        if (!options.forceAssetPublishing) {
            await (0, private_2.removePublishedAssetsFromWorkGraph)(workGraph, deployments, options);
        }
        const graphConcurrency = {
            'stack': concurrency,
            'asset-build': 1, // This will be CPU-bound/memory bound, mostly matters for Docker builds
            'asset-publish': (options.assetParallelism ?? true) ? 8 : 1, // This will be I/O-bound, 8 in parallel seems reasonable
        };
        await workGraph.doParallel(graphConcurrency, {
            deployStack,
            buildAsset,
            publishAsset,
        });
        return ret;
    }
    /**
     * Watch Action
     *
     * Continuously observe project files and deploy the selected stacks
     * automatically when changes are detected.  Implies hotswap deployments.
     *
     * This function returns immediately, starting a watcher in the background.
     */
    async watch(cx, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'watch');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx, false);
        const rootDir = options.watchDir ?? process.cwd();
        if (options.include === undefined && options.exclude === undefined) {
            throw new shared_private_1.ToolkitError("Cannot use the 'watch' command without specifying at least one directory to monitor. " +
                'Make sure to add a "watch" key to your cdk.json');
        }
        // For the "include" subkey under the "watch" key, the behavior is:
        // 1. No "watch" setting? We error out.
        // 2. "watch" setting without an "include" key? We default to observing "./**".
        // 3. "watch" setting with an empty "include" key? We default to observing "./**".
        // 4. Non-empty "include" key? Just use the "include" key.
        const watchIncludes = (0, private_4.patternsArrayForWatch)(options.include, {
            rootDir,
            returnRootDirIfEmpty: true,
        });
        // For the "exclude" subkey under the "watch" key,
        // the behavior is to add some default excludes in addition to the ones specified by the user:
        // 1. The CDK output directory.
        // 2. Any file whose name starts with a dot.
        // 3. Any directory's content whose name starts with a dot.
        // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
        const outdir = assembly.directory;
        const watchExcludes = (0, private_4.patternsArrayForWatch)(options.exclude, {
            rootDir,
            returnRootDirIfEmpty: false,
        });
        // only exclude the outdir if it is under the rootDir
        const relativeOutDir = path.relative(rootDir, outdir);
        if (Boolean(relativeOutDir && !relativeOutDir.startsWith('..' + path.sep) && !path.isAbsolute(relativeOutDir))) {
            watchExcludes.push(`${relativeOutDir}/**`);
        }
        watchExcludes.push('**/.*', '**/.*/**', '**/node_modules/**');
        // Print some debug information on computed settings
        await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5310.msg([
            `root directory used for 'watch' is: ${rootDir}`,
            `'include' patterns for 'watch': ${JSON.stringify(watchIncludes)}`,
            `'exclude' patterns for 'watch': ${JSON.stringify(watchExcludes)}`,
        ].join('\n'), {
            watchDir: rootDir,
            includes: watchIncludes,
            excludes: watchExcludes,
        }));
        let latch = 'pre-ready';
        const cloudWatchLogMonitor = options.traceLogs ? new shared_private_1.CloudWatchLogEventMonitor({ ioHelper }) : undefined;
        const deployAndWatch = async () => {
            latch = 'deploying';
            await cloudWatchLogMonitor?.deactivate();
            await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits',
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5315.msg("Detected file changes during deployment. Invoking 'cdk deploy' again"));
                await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
            }
            latch = 'open';
            await cloudWatchLogMonitor?.activate();
        };
        const watcher = chokidar
            .watch(watchIncludes, {
            ignored: watchExcludes,
            cwd: rootDir,
        })
            .on('ready', async () => {
            latch = 'open';
            await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_DEBUG.msg("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment"));
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5314.msg("Triggering initial 'cdk deploy'"));
            await deployAndWatch();
        })
            .on('all', async (event, filePath) => {
            const watchEvent = {
                event,
                path: filePath,
            };
            if (latch === 'pre-ready') {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5311.msg(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '${filePath}' for changes`, watchEvent));
            }
            else if (latch === 'open') {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5312.msg(`Detected change to '${filePath}' (type: ${event}). Triggering 'cdk deploy'`, watchEvent));
                await deployAndWatch();
            }
            else {
                // this means latch is either 'deploying' or 'queued'
                latch = 'queued';
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5313.msg(`Detected change to '${filePath}' (type: ${event}) while 'cdk deploy' is still running. Will queue for another deployment after this one finishes'`, watchEvent));
            }
        });
        const stoppedPromise = (0, promises_1.promiseWithResolvers)();
        return {
            async dispose() {
                await watcher.close();
                // Prevents Node from staying alive. There is no 'end' event that the watcher emits
                // that we can know it's definitely done, so best we can do is tell it to stop watching,
                // stop keeping Node alive, and then pretend that's everything we needed to do.
                watcher.unref();
                stoppedPromise.resolve();
                return stoppedPromise.promise;
            },
            async waitForEnd() {
                return stoppedPromise.promise;
            },
            async [Symbol.asyncDispose]() {
                return this.dispose();
            },
        };
    }
    /**
     * Rollback Action
     *
     * Rolls back the selected stacks.
     */
    async rollback(cx, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'rollback');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        return this._rollback(assembly, 'rollback', options);
    }
    /**
     * Helper to allow rollback being called as part of the deploy or watch action.
     */
    async _rollback(assembly, action, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: options.stacks });
        const stacks = await assembly.selectStacksV2(options.stacks);
        await this.validateStacksMetadata(stacks, ioHelper);
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stacks.stackCount === 0) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E6001.msg('No stacks selected'));
            return ret;
        }
        let anyRollbackable = false;
        for (const [index, stack] of stacks.stackArtifacts.entries()) {
            const rollbackSpan = await ioHelper.span(private_6.SPAN.ROLLBACK_STACK).begin(`Rolling back ${chalk.bold(stack.displayName)}`, {
                total: stacks.stackCount,
                current: index + 1,
                stack,
            });
            const deployments = await this.deploymentsForAction('rollback');
            try {
                const stackResult = await deployments.rollbackStack({
                    stack,
                    roleArn: options.roleArn,
                    toolkitStackName: this.toolkitStackName,
                    orphanFailedResources: options.orphanFailedResources,
                    validateBootstrapStackVersion: options.validateBootstrapStackVersion,
                    orphanLogicalIds: options.orphanLogicalIds,
                });
                if (!stackResult.notInRollbackableState) {
                    anyRollbackable = true;
                }
                await rollbackSpan.end();
                ret.stacks.push({
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackName: stack.stackName,
                    stackArn: stackResult.stackArn,
                    result: stackResult.notInRollbackableState ? 'already-stable' : 'rolled-back',
                });
            }
            catch (e) {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E6900.msg(`\n ❌  ${chalk.bold(stack.displayName)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw new shared_private_1.ToolkitError('Rollback failed (use --force to orphan failing resources)');
            }
        }
        if (!anyRollbackable) {
            throw new shared_private_1.ToolkitError('No stacks were in a state that could be rolled back');
        }
        return ret;
    }
    /**
     * Destroy Action
     *
     * Destroys the selected Stacks.
     */
    async destroy(cx, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'destroy');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        return this._destroy(assembly, 'destroy', options);
    }
    /**
     * Helper to allow destroy being called as part of the deploy action.
     */
    async _destroy(assembly, action, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: options.stacks });
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        const stacks = (await assembly.selectStacksV2(options.stacks)).reversed();
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        const motivation = 'Destroying stacks is an irreversible action';
        const question = `Are you sure you want to delete: ${chalk.red(stacks.hierarchicalIds.join(', '))}`;
        const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I7010.req(question, { motivation }));
        if (!confirmed) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E7010.msg('Aborted by user'));
            return ret;
        }
        const destroySpan = await ioHelper.span(private_6.SPAN.DESTROY_ACTION).begin({
            stacks: stacks.stackArtifacts,
        });
        try {
            for (const [index, stack] of stacks.stackArtifacts.entries()) {
                try {
                    const singleDestroySpan = await ioHelper.span(private_6.SPAN.DESTROY_STACK)
                        .begin(chalk.green(`${chalk.blue(stack.displayName)}: destroying... [${index + 1}/${stacks.stackCount}]`), {
                        total: stacks.stackCount,
                        current: index + 1,
                        stack,
                    });
                    const deployments = await this.deploymentsForAction(action);
                    const result = await deployments.destroyStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                    });
                    ret.stacks.push({
                        environment: {
                            account: stack.environment.account,
                            region: stack.environment.region,
                        },
                        stackName: stack.stackName,
                        stackArn: result.stackArn,
                        stackExisted: result.stackArn !== undefined,
                    });
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I7900.msg(chalk.green(`\n ✅  ${chalk.blue(stack.displayName)}: ${action}ed`), stack));
                    await singleDestroySpan.end();
                }
                catch (e) {
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E7900.msg(`\n ❌  ${chalk.blue(stack.displayName)}: ${action} failed ${e}`, { error: e }));
                    throw e;
                }
            }
            return ret;
        }
        finally {
            await destroySpan.end();
        }
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    async validateStacksMetadata(stacks, ioHost) {
        const builder = (level) => {
            switch (level) {
                case 'error': return private_6.IO.CDK_ASSEMBLY_E9999;
                case 'warn': return private_6.IO.CDK_ASSEMBLY_W9999;
                default: return private_6.IO.CDK_ASSEMBLY_I9999;
            }
        };
        await stacks.validateMetadata(this.props.assemblyFailureAt, async (level, msg) => ioHost.notify(builder(level).msg(`[${level} at ${msg.id}] ${msg.entry.data}`, msg)));
    }
    /**
     * Create a deployments class
     */
    async deploymentsForAction(action) {
        return new shared_private_1.Deployments({
            sdkProvider: await this.sdkProvider(action),
            toolkitStackName: this.toolkitStackName,
            ioHelper: (0, shared_private_1.asIoHelper)(this.ioHost, action),
        });
    }
    async invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor) {
        // watch defaults hotswap to enabled
        const hotswap = options.hotswap ?? shared_private_1.HotswapMode.HOTSWAP_ONLY;
        const deployOptions = {
            ...options,
            cloudWatchLogMonitor,
            hotswap,
            extraUserAgent: `cdk-watch/hotswap-${hotswap === shared_private_1.HotswapMode.FULL_DEPLOYMENT ? 'off' : 'on'}`,
        };
        try {
            await this._deploy(assembly, 'watch', deployOptions);
        }
        catch {
            // just continue - deploy will show the error
        }
    }
}
exports.Toolkit = Toolkit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRvb2xraXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsa0NBQWtDO0FBQ2xDLHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQix1RUFBaUU7QUFFakUsdUNBQStDO0FBRy9DLG9EQUF1RDtBQUN2RCw4Q0FBdUU7QUFDdkUsdURBQThKO0FBRzlKLHFEQUFvRztBQUtwRyxzREFBaUU7QUFHakUsMERBQStEO0FBRS9ELDJEQUFvSDtBQUVwSCwrQ0FBOEc7QUFFOUcsMERBQXdSO0FBRXhSLDBDQUEySDtBQUMzSCxxREFBNkM7QUFDN0MsK0NBQXdEO0FBNkN4RDs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLG9DQUEwQjtJQWdCakI7SUFmcEM7O09BRUc7SUFDYSxnQkFBZ0IsQ0FBUztJQUV6Qzs7T0FFRztJQUNhLE1BQU0sQ0FBVTtJQUVoQzs7T0FFRztJQUNLLGdCQUFnQixDQUFlO0lBRXZDLFlBQW9DLFFBQXdCLEVBQUU7UUFDNUQsS0FBSyxFQUFFLENBQUM7UUFEMEIsVUFBSyxHQUFMLEtBQUssQ0FBcUI7UUFFNUQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsSUFBSSwyQ0FBMEIsQ0FBQztRQUU3RSxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxJQUFJLElBQUksOENBQW9CLEVBQUUsQ0FBQztRQUN4RCxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFLENBQUM7WUFDM0IsTUFBTSxHQUFHLElBQUEsdUJBQWEsRUFBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBQ0QsSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLEtBQUssRUFBRSxDQUFDO1lBQzFCLE1BQU0sR0FBRyxJQUFBLHNCQUFZLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUNELHlHQUF5RztRQUN6Ryxx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cyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgY2hva2lkYXIgZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgTm9uSW50ZXJhY3RpdmVJb0hvc3QgfSBmcm9tICcuL25vbi1pbnRlcmFjdGl2ZS1pby1ob3N0JztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi9wcml2YXRlJztcbmltcG9ydCB7IGFzc2VtYmx5RnJvbVNvdXJjZSB9IGZyb20gJy4vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IERlcGxveVJlc3VsdCwgRGVzdHJveVJlc3VsdCwgUm9sbGJhY2tSZXN1bHQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgQm9vdHN0cmFwRW52aXJvbm1lbnRzLCBCb290c3RyYXBPcHRpb25zLCBCb290c3RyYXBSZXN1bHQsIEVudmlyb25tZW50Qm9vdHN0cmFwUmVzdWx0IH0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU291cmNlIH0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQXNzZXRCdWlsZFRpbWUsIHR5cGUgRGVwbG95T3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvZGVwbG95JztcbmltcG9ydCB7IHR5cGUgRXh0ZW5kZWREZXBsb3lPcHRpb25zLCBidWlsZFBhcmFtZXRlck1hcCwgY3JlYXRlSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLCByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoIH0gZnJvbSAnLi4vYWN0aW9ucy9kZXBsb3kvcHJpdmF0ZSc7XG5pbXBvcnQgeyB0eXBlIERlc3Ryb3lPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9kZXN0cm95JztcbmltcG9ydCB0eXBlIHsgRGlmZk9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2RpZmYnO1xuaW1wb3J0IHsgZGV0ZXJtaW5lUGVybWlzc2lvblR5cGUsIG1ha2VUZW1wbGF0ZUluZm9zIGFzIHByZXBhcmVEaWZmIH0gZnJvbSAnLi4vYWN0aW9ucy9kaWZmL3ByaXZhdGUnO1xuaW1wb3J0IHsgdHlwZSBMaXN0T3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvbGlzdCc7XG5pbXBvcnQgeyB0eXBlIFJvbGxiYWNrT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvcm9sbGJhY2snO1xuaW1wb3J0IHsgdHlwZSBTeW50aE9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3N5bnRoJztcbmltcG9ydCB0eXBlIHsgV2F0Y2hPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy93YXRjaCc7XG5pbXBvcnQgeyBwYXR0ZXJuc0FycmF5Rm9yV2F0Y2ggfSBmcm9tICcuLi9hY3Rpb25zL3dhdGNoL3ByaXZhdGUnO1xuaW1wb3J0IHsgdHlwZSBTZGtDb25maWcgfSBmcm9tICcuLi9hcGkvYXdzLWF1dGgnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseSc7XG5pbXBvcnQgeyBTdGFja1NlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vYXBpL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB0eXBlIHsgU3RhY2tBc3NlbWJseSB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseS9wcml2YXRlJztcbmltcG9ydCB7IEFMTF9TVEFDS1MsIENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyLCBJZGVudGl0eUNsb3VkQXNzZW1ibHlTb3VyY2UgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHkvcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IElJb0hvc3QsIElvTWVzc2FnZUxldmVsIH0gZnJvbSAnLi4vYXBpL2lvJztcbmltcG9ydCB7IElPLCBTUEFOLCBhc1Nka0xvZ2dlciwgd2l0aG91dENvbG9yLCB3aXRob3V0RW1vamlzLCB3aXRoVHJpbW1lZFdoaXRlc3BhY2UgfSBmcm9tICcuLi9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCwgQ29uY3VycmVuY3ksIEFzc2V0QnVpbGROb2RlLCBBc3NldFB1Ymxpc2hOb2RlLCBTdGFja05vZGUsIElvSGVscGVyLCBTdGFja0NvbGxlY3Rpb24gfSBmcm9tICcuLi9hcGkvc2hhcmVkLXByaXZhdGUnO1xuaW1wb3J0IHsgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciwgZmluZENsb3VkV2F0Y2hMb2dHcm91cHMsIERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FLCBCb290c3RyYXBwZXIsIERlcGxveW1lbnRzLCBSZXNvdXJjZU1pZ3JhdG9yLCBXb3JrR3JhcGhCdWlsZGVyLCBIb3Rzd2FwTW9kZSwgU2RrUHJvdmlkZXIsIGFzSW9IZWxwZXIsIERpZmZGb3JtYXR0ZXIsIFJlcXVpcmVBcHByb3ZhbCwgVG9vbGtpdEVycm9yLCB0YWdzRm9yU3RhY2sgfSBmcm9tICcuLi9hcGkvc2hhcmVkLXByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0QWN0aW9uLCBBc3NlbWJseURhdGEsIFN0YWNrRGV0YWlscyB9IGZyb20gJy4uL2FwaS9zaGFyZWQtcHVibGljJztcbmltcG9ydCB7IG9ic2N1cmVUZW1wbGF0ZSwgc2VyaWFsaXplU3RydWN0dXJlLCB2YWxpZGF0ZVNuc1RvcGljQXJuLCBmb3JtYXRUaW1lLCBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi9wcml2YXRlL3V0aWwnO1xuaW1wb3J0IHsgcExpbWl0IH0gZnJvbSAnLi4vdXRpbC9jb25jdXJyZW5jeSc7XG5pbXBvcnQgeyBwcm9taXNlV2l0aFJlc29sdmVycyB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xraXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBJb0hvc3QgaW1wbGVtZW50YXRpb24sIGhhbmRsaW5nIHRoZSBpbmxpbmUgaW50ZXJhY3Rpb25zIGJldHdlZW4gdGhlIFRvb2xraXQgYW5kIGFuIGludGVncmF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgaW9Ib3N0PzogSUlvSG9zdDtcblxuICAvKipcbiAgICogQWxsb3cgZW1vamlzIGluIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIElvSG9zdC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgZW1vamlzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbGxvdyBBTlNJIGNvbG9ycyBhbmQgZm9ybWF0dGluZyBpbiBJb0hvc3QgbWVzc2FnZXMuXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB0byBgZmFsc2VgIGVuZm9yY2VzIHRoYXQgbm8gY29sb3Igb3Igc3R5bGUgc2hvd3MgdXBcbiAgICogaW4gbWVzc2FnZXMgc2VudCB0byB0aGUgSW9Ib3N0LlxuICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgdG8gdHJ1ZSBpcyBhIG5vLW9wOyBpdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBkZWZhdWx0LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRldGVjdHMgY29sb3IgZnJvbSB0aGUgVFRZIHN0YXR1cyBvZiB0aGUgSW9Ib3N0XG4gICAqL1xuICByZWFkb25seSBjb2xvcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFNESy5cbiAgICovXG4gIHJlYWRvbmx5IHNka0NvbmZpZz86IFNka0NvbmZpZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjayB0byBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcIkNES1Rvb2xraXRcIlxuICAgKi9cbiAgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogRmFpbCBDbG91ZCBBc3NlbWJsaWVzXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiZXJyb3JcIlxuICAgKi9cbiAgcmVhZG9ubHkgYXNzZW1ibHlGYWlsdXJlQXQ/OiAnZXJyb3InIHwgJ3dhcm4nIHwgJ25vbmUnO1xufVxuXG4vKipcbiAqIFRoZSBBV1MgQ0RLIFByb2dyYW1tYXRpYyBUb29sa2l0XG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sa2l0IGV4dGVuZHMgQ2xvdWRBc3NlbWJseVNvdXJjZUJ1aWxkZXIge1xuICAvKipcbiAgICogVGhlIHRvb2xraXQgc3RhY2sgbmFtZSB1c2VkIGZvciBib290c3RyYXBwaW5nIHJlc291cmNlcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJb0hvc3Qgb2YgdGhpcyBUb29sa2l0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW9Ib3N0OiBJSW9Ib3N0O1xuXG4gIC8qKlxuICAgKiBDYWNoZSBvZiB0aGUgaW50ZXJuYWwgU0RLIFByb3ZpZGVyIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIHNka1Byb3ZpZGVyQ2FjaGU/OiBTZGtQcm92aWRlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogVG9vbGtpdE9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50b29sa2l0U3RhY2tOYW1lID0gcHJvcHMudG9vbGtpdFN0YWNrTmFtZSA/PyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRTtcblxuICAgIGxldCBpb0hvc3QgPSBwcm9wcy5pb0hvc3QgPz8gbmV3IE5vbkludGVyYWN0aXZlSW9Ib3N0KCk7XG4gICAgaWYgKHByb3BzLmVtb2ppcyA9PT0gZmFsc2UpIHtcbiAgICAgIGlvSG9zdCA9IHdpdGhvdXRFbW9qaXMoaW9Ib3N0KTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNvbG9yID09PSBmYWxzZSkge1xuICAgICAgaW9Ib3N0ID0gd2l0aG91dENvbG9yKGlvSG9zdCk7XG4gICAgfVxuICAgIC8vIEFmdGVyIHJlbW92aW5nIGVtb2ppcyBhbmQgY29sb3IsIHdlIG1pZ2h0IGVuZCB1cCB3aXRoIGZsb2F0aW5nIHdoaXRlc3BhY2UgYXQgZWl0aGVyIGVuZCBvZiB0aGUgbWVzc2FnZVxuICAgIC8vIFRoaXMgYWxzbyByZW1vdmVzIG5ld2xpbmVzIHRoYXQgd2UgY3VycmVudGx5IGVtaXQgZm9yIENMSSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB0aGlzLmlvSG9zdCA9IHdpdGhUcmltbWVkV2hpdGVzcGFjZShpb0hvc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0byB0aGUgQVdTIFNES1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBzZGtQcm92aWRlcihhY3Rpb246IFRvb2xraXRBY3Rpb24pOiBQcm9taXNlPFNka1Byb3ZpZGVyPiB7XG4gICAgLy8gQHRvZG8gdGhpcyBuZWVkcyB0byBiZSBkaWZmZXJlbnQgaW5zdGFuY2UgcGVyIGFjdGlvblxuICAgIGlmICghdGhpcy5zZGtQcm92aWRlckNhY2hlKSB7XG4gICAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbik7XG4gICAgICB0aGlzLnNka1Byb3ZpZGVyQ2FjaGUgPSBhd2FpdCBTZGtQcm92aWRlci53aXRoQXdzQ2xpQ29tcGF0aWJsZURlZmF1bHRzKHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5zZGtDb25maWcsXG4gICAgICAgIGlvSGVscGVyLFxuICAgICAgICBsb2dnZXI6IGFzU2RrTG9nZ2VyKGlvSGVscGVyKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNka1Byb3ZpZGVyQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIHByb3ZpZGUgdGhlIENsb3VkQXNzZW1ibHlTb3VyY2VCdWlsZGVyIHdpdGggcmVxdWlyZWQgdG9vbGtpdCBzZXJ2aWNlc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBvdmVycmlkZSBhc3luYyBzb3VyY2VCdWlsZGVyU2VydmljZXMoKTogUHJvbWlzZTxUb29sa2l0U2VydmljZXM+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaW9IZWxwZXI6IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdhc3NlbWJseScpLFxuICAgICAgc2RrUHJvdmlkZXI6IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2Fzc2VtYmx5JyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb290c3RyYXAgQWN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYm9vdHN0cmFwKGVudmlyb25tZW50czogQm9vdHN0cmFwRW52aXJvbm1lbnRzLCBvcHRpb25zOiBCb290c3RyYXBPcHRpb25zKTogUHJvbWlzZTxCb290c3RyYXBSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJlc3VsdHM6IEVudmlyb25tZW50Qm9vdHN0cmFwUmVzdWx0W10gPSBbXTtcblxuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2Jvb3RzdHJhcCcpO1xuICAgIGNvbnN0IGJvb3RzdHJhcEVudmlyb25tZW50cyA9IGF3YWl0IGVudmlyb25tZW50cy5nZXRFbnZpcm9ubWVudHModGhpcy5pb0hvc3QpO1xuICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMuc291cmNlID8/IEJvb3RzdHJhcFNvdXJjZS5kZWZhdWx0KCk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG9wdGlvbnMucGFyYW1ldGVycztcbiAgICBjb25zdCBib290c3RyYXBwZXIgPSBuZXcgQm9vdHN0cmFwcGVyKHNvdXJjZSwgaW9IZWxwZXIpO1xuICAgIGNvbnN0IHNka1Byb3ZpZGVyID0gYXdhaXQgdGhpcy5zZGtQcm92aWRlcignYm9vdHN0cmFwJyk7XG4gICAgY29uc3QgbGltaXQgPSBwTGltaXQoMjApO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoYm9vdHN0cmFwRW52aXJvbm1lbnRzLm1hcCgoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBjdXJyZW50SWR4KSA9PiBsaW1pdChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBib290c3RyYXBTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkJPT1RTVFJBUF9TSU5HTEUpXG4gICAgICAgIC5iZWdpbihgJHtjaGFsay5ib2xkKGVudmlyb25tZW50Lm5hbWUpfTogYm9vdHN0cmFwcGluZy4uLmAsIHtcbiAgICAgICAgICB0b3RhbDogYm9vdHN0cmFwRW52aXJvbm1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjdXJyZW50OiBjdXJyZW50SWR4KzEsXG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBib290c3RyYXBSZXN1bHQgPSBhd2FpdCBib290c3RyYXBwZXIuYm9vdHN0cmFwRW52aXJvbm1lbnQoXG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnM/LnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB1c2VQcmV2aW91c1BhcmFtZXRlcnM6IHBhcmFtZXRlcnM/LmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYm9vdHN0cmFwUmVzdWx0Lm5vT3BcbiAgICAgICAgICA/IGAg4pyFICAke2Vudmlyb25tZW50Lm5hbWV9IChubyBjaGFuZ2VzKWBcbiAgICAgICAgICA6IGAg4pyFICAke2Vudmlyb25tZW50Lm5hbWV9YDtcblxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTk5MDAubXNnKGNoYWxrLmdyZWVuKCdcXG4nICsgbWVzc2FnZSksIHsgZW52aXJvbm1lbnQgfSkpO1xuICAgICAgICBjb25zdCBlbnZUaW1lID0gYXdhaXQgYm9vdHN0cmFwU3Bhbi5lbmQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdCA9IHtcbiAgICAgICAgICBlbnZpcm9ubWVudCxcbiAgICAgICAgICBzdGF0dXM6IGJvb3RzdHJhcFJlc3VsdC5ub09wID8gJ25vLW9wJyA6ICdzdWNjZXNzJyxcbiAgICAgICAgICBkdXJhdGlvbjogZW52VGltZS5hc01zLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTk5MDAubXNnKGBcXG4g4p2MICAke2NoYWxrLmJvbGQoZW52aXJvbm1lbnQubmFtZSl9IGZhaWxlZDogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCwgeyBlcnJvcjogZSB9KSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSkpKTtcblxuICAgIHJldHVybiB7XG4gICAgICBlbnZpcm9ubWVudHM6IHJlc3VsdHMsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bnRoIEFjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIHN5bnRoKGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogU3ludGhPcHRpb25zID0ge30pOiBQcm9taXNlPElDbG91ZEFzc2VtYmx5U291cmNlPiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnc3ludGgnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgY29uc3QgYXV0b1ZhbGlkYXRlU3RhY2tzID0gb3B0aW9ucy52YWxpZGF0ZVN0YWNrcyA/IFthc3NlbWJseS5zZWxlY3RTdGFja3NGb3JWYWxpZGF0aW9uKCldIDogW107XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrcy5jb25jYXQoLi4uYXV0b1ZhbGlkYXRlU3RhY2tzKSwgaW9IZWxwZXIpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgU3VjY2Vzc2Z1bGx5IHN5bnRoZXNpemVkIHRvICR7Y2hhbGsuYmx1ZShwYXRoLnJlc29sdmUoc3RhY2tzLmFzc2VtYmx5LmRpcmVjdG9yeSkpfWA7XG4gICAgY29uc3QgYXNzZW1ibHlEYXRhOiBBc3NlbWJseURhdGEgPSB7XG4gICAgICBhc3NlbWJseURpcmVjdG9yeTogc3RhY2tzLmFzc2VtYmx5LmRpcmVjdG9yeSxcbiAgICAgIHN0YWNrc0NvdW50OiBzdGFja3Muc3RhY2tDb3VudCxcbiAgICAgIHN0YWNrSWRzOiBzdGFja3MuaGllcmFyY2hpY2FsSWRzLFxuICAgIH07XG5cbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpcnN0U3RhY2sgPSBzdGFja3MuZmlyc3RTdGFjayE7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGZpcnN0U3RhY2sudGVtcGxhdGU7XG4gICAgICBjb25zdCBvYnNjdXJlZFRlbXBsYXRlID0gb2JzY3VyZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JMTkwMS5tc2cobWVzc2FnZSwge1xuICAgICAgICAuLi5hc3NlbWJseURhdGEsXG4gICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgc3RhY2tOYW1lOiBmaXJzdFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICBoaWVyYXJjaGljYWxJZDogZmlyc3RTdGFjay5oaWVyYXJjaGljYWxJZCxcbiAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICBzdHJpbmdpZmllZEpzb246IHNlcmlhbGl6ZVN0cnVjdHVyZShvYnNjdXJlZFRlbXBsYXRlLCB0cnVlKSxcbiAgICAgICAgICBzdHJpbmdpZmllZFlhbWw6IHNlcmlhbGl6ZVN0cnVjdHVyZShvYnNjdXJlZFRlbXBsYXRlLCBmYWxzZSksXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBvdXRwdXR0aW5nIHRlbXBsYXRlIHRvIHN0ZG91dCwgbGV0J3MgZXhwbGFpbiB0aGluZ3MgdG8gdGhlIHVzZXIgYSBsaXR0bGUgYml0Li4uXG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTE5MDIubXNnKGNoYWxrLmdyZWVuKG1lc3NhZ2UpLCBhc3NlbWJseURhdGEpKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2coYFN1cHBseSBhIHN0YWNrIGlkICgke3N0YWNrcy5zdGFja0FydGlmYWN0cy5tYXAoKHMpID0+IGNoYWxrLmdyZWVuKHMuaGllcmFyY2hpY2FsSWQpKS5qb2luKCcsICcpfSkgdG8gZGlzcGxheSBpdHMgdGVtcGxhdGUuYCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSWRlbnRpdHlDbG91ZEFzc2VtYmx5U291cmNlKGFzc2VtYmx5LmFzc2VtYmx5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWZmIEFjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpZmYoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBEaWZmT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2RpZmYnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3QgZGlmZlNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uRElGRl9TVEFDSykuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oJ2RpZmYnKTtcblxuICAgIGNvbnN0IHN0cmljdCA9ICEhb3B0aW9ucy5zdHJpY3Q7XG4gICAgY29uc3QgY29udGV4dExpbmVzID0gb3B0aW9ucy5jb250ZXh0TGluZXMgfHwgMztcblxuICAgIGxldCBkaWZmcyA9IDA7XG4gICAgbGV0IGZvcm1hdHRlZFNlY3VyaXR5RGlmZiA9ICcnO1xuICAgIGxldCBmb3JtYXR0ZWRTdGFja0RpZmYgPSAnJztcblxuICAgIGNvbnN0IHRlbXBsYXRlSW5mb3MgPSBhd2FpdCBwcmVwYXJlRGlmZihpb0hlbHBlciwgc3RhY2tzLCBkZXBsb3ltZW50cywgYXdhaXQgdGhpcy5zZGtQcm92aWRlcignZGlmZicpLCBvcHRpb25zKTtcblxuICAgIGZvciAoY29uc3QgdGVtcGxhdGVJbmZvIG9mIHRlbXBsYXRlSW5mb3MpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBEaWZmRm9ybWF0dGVyKHtcbiAgICAgICAgaW9IZWxwZXIsXG4gICAgICAgIHRlbXBsYXRlSW5mbyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zZWN1cml0eU9ubHkpIHtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlEaWZmID0gZm9ybWF0dGVyLmZvcm1hdFNlY3VyaXR5RGlmZih7XG4gICAgICAgICAgcmVxdWlyZUFwcHJvdmFsOiBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklORyxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1hdHRlZFNlY3VyaXR5RGlmZiA9IHNlY3VyaXR5RGlmZi5mb3JtYXR0ZWREaWZmID8/ICcnO1xuICAgICAgICBkaWZmcyA9IHNlY3VyaXR5RGlmZi5mb3JtYXR0ZWREaWZmID8gZGlmZnMgKyAxIDogZGlmZnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkaWZmID0gZm9ybWF0dGVyLmZvcm1hdFN0YWNrRGlmZih7XG4gICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRMaW5lcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1hdHRlZFN0YWNrRGlmZiA9IGRpZmYuZm9ybWF0dGVkRGlmZjtcbiAgICAgICAgZGlmZnMgPSBkaWZmLm51bVN0YWNrc1dpdGhDaGFuZ2VzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IGRpZmZTcGFuLmVuZChg4pyoIE51bWJlciBvZiBzdGFja3Mgd2l0aCBkaWZmZXJlbmNlczogJHtkaWZmc31gLCB7XG4gICAgICBmb3JtYXR0ZWRTZWN1cml0eURpZmYsXG4gICAgICBmb3JtYXR0ZWRTdGFja0RpZmYsXG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBBY3Rpb25cbiAgICpcbiAgICogTGlzdCBzZWxlY3RlZCBzdGFja3MgYW5kIHRoZWlyIGRlcGVuZGVuY2llc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3QoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBMaXN0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxTdGFja0RldGFpbHNbXT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2xpc3QnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gc3RhY2tDb2xsZWN0aW9uLndpdGhEZXBlbmRlbmNpZXMoKTtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhY2tzLm1hcChzID0+IHMuaWQpLmpvaW4oJ1xcbicpO1xuXG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0kyOTAxLm1zZyhtZXNzYWdlLCB7IHN0YWNrcyB9KSk7XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgQWN0aW9uXG4gICAqXG4gICAqIERlcGxveXMgdGhlIHNlbGVjdGVkIHN0YWNrcyBpbnRvIGFuIEFXUyBhY2NvdW50XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVwbG95KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogRGVwbG95T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkZXBsb3knKTtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIHJldHVybiB0aGlzLl9kZXBsb3koYXNzZW1ibHksICdkZXBsb3knLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWxsb3cgZGVwbG95IGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIHRoZSB3YXRjaCBhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9kZXBsb3koYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksIGFjdGlvbjogJ2RlcGxveScgfCAnd2F0Y2gnLCBvcHRpb25zOiBFeHRlbmRlZERlcGxveU9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrQ29sbGVjdGlvbiwgaW9IZWxwZXIpO1xuICAgIGNvbnN0IHN5bnRoRHVyYXRpb24gPSBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IERlcGxveVJlc3VsdCA9IHtcbiAgICAgIHN0YWNrczogW10sXG4gICAgfTtcblxuICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U1MDAxLm1zZygnVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJykpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oJ2RlcGxveScpO1xuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IFJlc291cmNlTWlncmF0b3IoeyBkZXBsb3ltZW50cywgaW9IZWxwZXIgfSk7XG5cbiAgICBhd2FpdCBtaWdyYXRvci50cnlNaWdyYXRlUmVzb3VyY2VzKHN0YWNrQ29sbGVjdGlvbiwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJNYXAgPSBidWlsZFBhcmFtZXRlck1hcChvcHRpb25zLnBhcmFtZXRlcnM/LnBhcmFtZXRlcnMpO1xuXG4gICAgY29uc3QgaG90c3dhcE1vZGUgPSBvcHRpb25zLmhvdHN3YXAgPz8gSG90c3dhcE1vZGUuRlVMTF9ERVBMT1lNRU5UO1xuICAgIGlmIChob3Rzd2FwTW9kZSAhPT0gSG90c3dhcE1vZGUuRlVMTF9ERVBMT1lNRU5UKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfVzU0MDAubXNnKFtcbiAgICAgICAgJ+KaoO+4jyBUaGUgLS1ob3Rzd2FwIGFuZCAtLWhvdHN3YXAtZmFsbGJhY2sgZmxhZ3MgZGVsaWJlcmF0ZWx5IGludHJvZHVjZSBDbG91ZEZvcm1hdGlvbiBkcmlmdCB0byBzcGVlZCB1cCBkZXBsb3ltZW50cycsXG4gICAgICAgICfimqDvuI8gVGhleSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBkZXZlbG9wbWVudCAtIG5ldmVyIHVzZSB0aGVtIGZvciB5b3VyIHByb2R1Y3Rpb24gU3RhY2tzIScsXG4gICAgICBdLmpvaW4oJ1xcbicpKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tzID0gc3RhY2tDb2xsZWN0aW9uLnN0YWNrQXJ0aWZhY3RzO1xuICAgIGNvbnN0IHN0YWNrT3V0cHV0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dHNGaWxlID0gb3B0aW9ucy5vdXRwdXRzRmlsZTtcblxuICAgIGNvbnN0IGJ1aWxkQXNzZXQgPSBhc3luYyAoYXNzZXROb2RlOiBBc3NldEJ1aWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgYnVpbGRBc3NldFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uQlVJTERfQVNTRVQpLmJlZ2luKHtcbiAgICAgICAgYXNzZXQ6IGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZGVwbG95bWVudHMuYnVpbGRTaW5nbGVBc3NldChcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3RBcnRpZmFjdCxcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsXG4gICAgICAgIGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgICAge1xuICAgICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBidWlsZEFzc2V0U3Bhbi5lbmQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHVibGlzaEFzc2V0ID0gYXN5bmMgKGFzc2V0Tm9kZTogQXNzZXRQdWJsaXNoTm9kZSkgPT4ge1xuICAgICAgY29uc3QgcHVibGlzaEFzc2V0U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5QVUJMSVNIX0FTU0VUKS5iZWdpbih7XG4gICAgICAgIGFzc2V0OiBhc3NldE5vZGUuYXNzZXQsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlcGxveW1lbnRzLnB1Ymxpc2hTaW5nbGVBc3NldChhc3NldE5vZGUuYXNzZXRNYW5pZmVzdCwgYXNzZXROb2RlLmFzc2V0LCB7XG4gICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgc3RhY2tOYW1lOiBhc3NldE5vZGUucGFyZW50U3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBmb3JjZVB1Ymxpc2g6IG9wdGlvbnMuZm9yY2VBc3NldFB1Ymxpc2hpbmcsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHB1Ymxpc2hBc3NldFNwYW4uZW5kKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlcGxveVN0YWNrID0gYXN5bmMgKHN0YWNrTm9kZTogU3RhY2tOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IHN0YWNrTm9kZS5zdGFjaztcbiAgICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgU3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgZGVmaW5lIGFuIGVudmlyb25tZW50LCBhbmQgQVdTIGNyZWRlbnRpYWxzIGNvdWxkIG5vdCBiZSBvYnRhaW5lZCBmcm9tIHN0YW5kYXJkIGxvY2F0aW9ucyBvciBubyByZWdpb24gd2FzIGNvbmZpZ3VyZWQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGdlbmVyYXRlZCBzdGFjayBoYXMgbm8gcmVzb3VyY2VzXG4gICAgICBpZiAoT2JqZWN0LmtleXMoc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzIHx8IHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHkgYW5kIGRvZXNuJ3QgZXhpc3QgPT4gZG8gbm90aGluZ1xuICAgICAgICBjb25zdCBzdGFja0V4aXN0cyA9IGF3YWl0IGRlcGxveW1lbnRzLnN0YWNrRXhpc3RzKHsgc3RhY2sgfSk7XG4gICAgICAgIGlmICghc3RhY2tFeGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX1c1MDIxLm1zZyhgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX06IHN0YWNrIGhhcyBubyByZXNvdXJjZXMsIHNraXBwaW5nIGRlcGxveW1lbnQuYCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHksIGJ1dCBleGlzdHMgPT4gZGVsZXRlXG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XNTAyMi5tc2coYCR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9OiBzdGFjayBoYXMgbm8gcmVzb3VyY2VzLCBkZWxldGluZyBleGlzdGluZyBzdGFjay5gKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Rlc3Ryb3koYXNzZW1ibHksICdkZXBsb3knLCB7XG4gICAgICAgICAgc3RhY2tzOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLCBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFIH0sXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2spO1xuICAgICAgY29uc3QgcGVybWlzc2lvbkNoYW5nZVR5cGUgPSBkZXRlcm1pbmVQZXJtaXNzaW9uVHlwZShjdXJyZW50VGVtcGxhdGUsIHN0YWNrKTtcbiAgICAgIGNvbnN0IGRlcGxveU1vdGl2YXRpb24gPSAnXCItLXJlcXVpcmUtYXBwcm92YWxcIiBpcyBlbmFibGVkIGFuZCBzdGFjayBpbmNsdWRlcyBzZWN1cml0eS1zZW5zaXRpdmUgdXBkYXRlcy4nO1xuICAgICAgY29uc3QgZGVwbG95UXVlc3Rpb24gPSBgJHtkZXBsb3lNb3RpdmF0aW9ufVxcbkRvIHlvdSB3aXNoIHRvIGRlcGxveSB0aGVzZSBjaGFuZ2VzYDtcbiAgICAgIGNvbnN0IGRlcGxveUNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNTA2MC5yZXEoZGVwbG95UXVlc3Rpb24sIHtcbiAgICAgICAgbW90aXZhdGlvbjogZGVwbG95TW90aXZhdGlvbixcbiAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgIHBlcm1pc3Npb25DaGFuZ2VUeXBlLFxuICAgICAgfSkpO1xuICAgICAgaWYgKCFkZXBsb3lDb25maXJtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvbGxvd2luZyBhcmUgdGhlIHNhbWUgc2VtYW50aWNzIHdlIGFwcGx5IHdpdGggcmVzcGVjdCB0byBOb3RpZmljYXRpb24gQVJOcyAoZGljdGF0ZWQgYnkgdGhlIFNESylcbiAgICAgIC8vXG4gICAgICAvLyAgLSB1bmRlZmluZWQgID0+ICBjZGsgaWdub3JlcyBpdCwgYXMgaWYgaXQgd2Fzbid0IHN1cHBvcnRlZCAoYWxsb3dzIGV4dGVybmFsIG1hbmFnZW1lbnQpLlxuICAgICAgLy8gIC0gW106ICAgICAgICA9PiAgY2RrIG1hbmFnZXMgaXQsIGFuZCB0aGUgdXNlciB3YW50cyB0byB3aXBlIGl0IG91dC5cbiAgICAgIC8vICAtIFsnYXJuLTEnXSAgPT4gIGNkayBtYW5hZ2VzIGl0LCBhbmQgdGhlIHVzZXIgd2FudHMgdG8gc2V0IGl0IHRvIFsnYXJuLTEnXS5cbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkFybnMgPSAoISFvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgfHwgISFzdGFjay5ub3RpZmljYXRpb25Bcm5zKVxuICAgICAgICA/IChvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgPz8gW10pLmNvbmNhdChzdGFjay5ub3RpZmljYXRpb25Bcm5zID8/IFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgZm9yIChjb25zdCBub3RpZmljYXRpb25Bcm4gb2Ygbm90aWZpY2F0aW9uQXJucyA/PyBbXSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlU25zVG9waWNBcm4obm90aWZpY2F0aW9uQXJuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE5vdGlmaWNhdGlvbiBhcm4gJHtub3RpZmljYXRpb25Bcm59IGlzIG5vdCBhIHZhbGlkIGFybiBmb3IgYW4gU05TIHRvcGljYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHN0YWNrcy5pbmRleE9mKHN0YWNrKSArIDE7XG4gICAgICBjb25zdCBkZXBsb3lTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRFUExPWV9TVEFDSylcbiAgICAgICAgLmJlZ2luKGAke2NoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpfTogZGVwbG95aW5nLi4uIFske3N0YWNrSW5kZXh9LyR7c3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnR9XWAsIHtcbiAgICAgICAgICB0b3RhbDogc3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnQsXG4gICAgICAgICAgY3VycmVudDogc3RhY2tJbmRleCxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgfSk7XG5cbiAgICAgIGxldCB0YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgaWYgKCF0YWdzIHx8IHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRhZ3MgPSB0YWdzRm9yU3RhY2soc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGVwbG95RHVyYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZGVwbG95UmVzdWx0OiBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IHJvbGxiYWNrID0gb3B0aW9ucy5yb2xsYmFjaztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICghZGVwbG95UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCsraXRlcmF0aW9uID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVGhpcyBsb29wIHNob3VsZCBoYXZlIHN0YWJpbGl6ZWQgaW4gMiBpdGVyYXRpb25zLCBidXQgZGlkblxcJ3QuIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IGRlcGxveW1lbnRzLmRlcGxveVN0YWNrKHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZTogdGhpcy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgICAgcmV1c2VBc3NldHM6IG9wdGlvbnMucmV1c2VBc3NldHMsXG4gICAgICAgICAgICBub3RpZmljYXRpb25Bcm5zLFxuICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgIGRlcGxveW1lbnRNZXRob2Q6IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZCxcbiAgICAgICAgICAgIGZvcmNlRGVwbG95bWVudDogb3B0aW9ucy5mb3JjZURlcGxveW1lbnQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJNYXBbJyonXSwgcGFyYW1ldGVyTWFwW3N0YWNrLnN0YWNrTmFtZV0pLFxuICAgICAgICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnM/LmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xsYmFjayxcbiAgICAgICAgICAgIGhvdHN3YXA6IGhvdHN3YXBNb2RlLFxuICAgICAgICAgICAgZXh0cmFVc2VyQWdlbnQ6IG9wdGlvbnMuZXh0cmFVc2VyQWdlbnQsXG4gICAgICAgICAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IG9wdGlvbnMuaG90c3dhcFByb3BlcnRpZXMgPyBjcmVhdGVIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMob3B0aW9ucy5ob3Rzd2FwUHJvcGVydGllcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhc3NldFBhcmFsbGVsaXNtOiBvcHRpb25zLmFzc2V0UGFyYWxsZWxpc20sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlkLWRlcGxveS1zdGFjayc6XG4gICAgICAgICAgICAgIGRlcGxveVJlc3VsdCA9IHI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdmYWlscGF1c2VkLW5lZWQtcm9sbGJhY2stZmlyc3QnOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSByLnJlYXNvbiA9PT0gJ3JlcGxhY2VtZW50J1xuICAgICAgICAgICAgICAgID8gYFN0YWNrIGlzIGluIGEgcGF1c2VkIGZhaWwgc3RhdGUgKCR7ci5zdGF0dXN9KSBhbmQgY2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCJgXG4gICAgICAgICAgICAgICAgOiBgU3RhY2sgaXMgaW4gYSBwYXVzZWQgZmFpbCBzdGF0ZSAoJHtyLnN0YXR1c30pIGFuZCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIGRvIG5vdCBpbmNsdWRlIFwiLS1uby1yb2xsYmFja1wiYDtcbiAgICAgICAgICAgICAgY29uc3QgcXVlc3Rpb24gPSBgJHttb3RpdmF0aW9ufS4gUGVyZm9ybSBhIHJlZ3VsYXIgZGVwbG95bWVudGA7XG5cbiAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgaW9IZWxwZXIucmVxdWVzdFJlc3BvbnNlKElPLkNES19UT09MS0lUX0k1MDUwLnJlcShxdWVzdGlvbiwge1xuICAgICAgICAgICAgICAgIG1vdGl2YXRpb24sXG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdBYm9ydGVkIGJ5IHVzZXInKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFBlcmZvcm0gYSByb2xsYmFja1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yb2xsYmFjayhhc3NlbWJseSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgc3RhY2tzOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLCBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFIH0sXG4gICAgICAgICAgICAgICAgb3JwaGFuRmFpbGVkUmVzb3VyY2VzOiBvcHRpb25zLm9ycGhhbkZhaWxlZFJlc291cmNlc0R1cmluZ1JvbGxiYWNrLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBHbyBhcm91bmQgdGhyb3VnaCB0aGUgJ3doaWxlJyBsb29wIGFnYWluIGJ1dCBzd2l0Y2ggcm9sbGJhY2sgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgcm9sbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZW1lbnQtcmVxdWlyZXMtcm9sbGJhY2snOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnQ2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCInO1xuICAgICAgICAgICAgICBjb25zdCBxdWVzdGlvbiA9IGAke21vdGl2YXRpb259LiBQZXJmb3JtIGEgcmVndWxhciBkZXBsb3ltZW50YDtcblxuICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBpb0hlbHBlci5yZXF1ZXN0UmVzcG9uc2UoSU8uQ0RLX1RPT0xLSVRfSTUwNTAucmVxKHF1ZXN0aW9uLCB7XG4gICAgICAgICAgICAgICAgbW90aXZhdGlvbixcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR28gYXJvdW5kIHRocm91Z2ggdGhlICd3aGlsZScgbG9vcCBhZ2FpbiBidXQgc3dpdGNoIHJvbGxiYWNrIHRvIHRydWUuXG4gICAgICAgICAgICAgIHJvbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBkZXBsb3lTdGFjazogJHtKU09OLnN0cmluZ2lmeShyKX0uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRlcGxveVJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJHtzdGFjay5kaXNwbGF5TmFtZX0gKG5vIGNoYW5nZXMpYFxuICAgICAgICAgIDogYCDinIUgICR7c3RhY2suZGlzcGxheU5hbWV9YDtcblxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU5MDAubXNnKGNoYWxrLmdyZWVuKCdcXG4nICsgbWVzc2FnZSksIGRlcGxveVJlc3VsdCkpO1xuICAgICAgICBkZXBsb3lEdXJhdGlvbiA9IGF3YWl0IGRlcGxveVNwYW4udGltaW5nKElPLkNES19UT09MS0lUX0k1MDAwKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVwbG95UmVzdWx0Lm91dHB1dHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBbJ091dHB1dHM6J107XG4gICAgICAgICAgc3RhY2tPdXRwdXRzW3N0YWNrLnN0YWNrTmFtZV0gPSBkZXBsb3lSZXN1bHQub3V0cHV0cztcblxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkZXBsb3lSZXN1bHQub3V0cHV0cykuc29ydCgpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlcGxveVJlc3VsdC5vdXRwdXRzW25hbWVdO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goYCR7Y2hhbGsuY3lhbihzdGFjay5pZCl9LiR7Y2hhbGsuY3lhbihuYW1lKX0gPSAke2NoYWxrLnVuZGVybGluZShjaGFsay5jeWFuKHZhbHVlKSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTkwMS5tc2coYnVmZmVyLmpvaW4oJ1xcbicpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1OTAxLm1zZyhgU3RhY2sgQVJOOlxcbiR7ZGVwbG95UmVzdWx0LnN0YWNrQXJufWApKTtcblxuICAgICAgICByZXQuc3RhY2tzLnB1c2goe1xuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICBhY2NvdW50OiBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgICAgICAgcmVnaW9uOiBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFja0FybjogZGVwbG95UmVzdWx0LnN0YWNrQXJuLFxuICAgICAgICAgIG91dHB1dHM6IGRlcGxveVJlc3VsdC5vdXRwdXRzLFxuICAgICAgICAgIGhpZXJhcmNoaWNhbElkOiBzdGFjay5oaWVyYXJjaGljYWxJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gSXQgaGFzIHRvIGJlIGV4YWN0bHkgdGhpcyBzdHJpbmcgYmVjYXVzZSBhbiBpbnRlZ3JhdGlvbiB0ZXN0IHRlc3RzIGZvclxuICAgICAgICAvLyBcImJvbGQoc3RhY2tuYW1lKSBmYWlsZWQ6IFJlc291cmNlTm90UmVhZHk6IDxlcnJvcj5cIlxuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIFtg4p2MICAke2NoYWxrLmJvbGQoc3RhY2suc3RhY2tOYW1lKX0gZmFpbGVkOmAsIC4uLihlLm5hbWUgPyBbYCR7ZS5uYW1lfTpgXSA6IFtdKSwgZS5tZXNzYWdlXS5qb2luKCcgJyksXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmFjZUxvZ3MpIHtcbiAgICAgICAgICAvLyBkZXBsb3kgY2FsbHMgdGhhdCBvcmlnaW5hdGUgZnJvbSB3YXRjaCB3aWxsIGNvbWUgd2l0aCB0aGVpciBvd24gY2xvdWRXYXRjaExvZ01vbml0b3JcbiAgICAgICAgICBjb25zdCBjbG91ZFdhdGNoTG9nTW9uaXRvciA9IG9wdGlvbnMuY2xvdWRXYXRjaExvZ01vbml0b3IgPz8gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IoeyBpb0hlbHBlciB9KTtcbiAgICAgICAgICBjb25zdCBmb3VuZExvZ0dyb3Vwc1Jlc3VsdCA9IGF3YWl0IGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzKGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2RlcGxveScpLCBpb0hlbHBlciwgc3RhY2spO1xuICAgICAgICAgIGNsb3VkV2F0Y2hMb2dNb25pdG9yLmFkZExvZ0dyb3VwcyhcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmVudixcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LnNkayxcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUwMzEubXNnKGBUaGUgZm9sbG93aW5nIGxvZyBncm91cHMgYXJlIGFkZGVkOiAke2ZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXN9YCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW4gb3V0cHV0cyBmaWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgY3JlYXRlIHRoZSBmaWxlIHBhdGggYW5kIHdyaXRlIHN0YWNrIG91dHB1dHMgdG8gaXQgb25jZS5cbiAgICAgICAgLy8gT3V0cHV0cyBhcmUgd3JpdHRlbiBhZnRlciBhbGwgc3RhY2tzIGhhdmUgYmVlbiBkZXBsb3llZC4gSWYgYSBzdGFjayBkZXBsb3ltZW50IGZhaWxzLFxuICAgICAgICAvLyBhbGwgb2YgdGhlIG91dHB1dHMgZnJvbSBzdWNjZXNzZnVsbHkgZGVwbG95ZWQgc3RhY2tzIGJlZm9yZSB0aGUgZmFpbHVyZSB3aWxsIHN0aWxsIGJlIHdyaXR0ZW4uXG4gICAgICAgIGlmIChvdXRwdXRzRmlsZSkge1xuICAgICAgICAgIGZzLmVuc3VyZUZpbGVTeW5jKG91dHB1dHNGaWxlKTtcbiAgICAgICAgICBhd2FpdCBmcy53cml0ZUpzb24ob3V0cHV0c0ZpbGUsIHN0YWNrT3V0cHV0cywge1xuICAgICAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb24gPSBzeW50aER1cmF0aW9uLmFzTXMgKyAoZGVwbG95RHVyYXRpb24/LmFzTXMgPz8gMCk7XG4gICAgICBhd2FpdCBkZXBsb3lTcGFuLmVuZChgXFxu4pyoICBUb3RhbCB0aW1lOiAke2Zvcm1hdFRpbWUoZHVyYXRpb24pfXNcXG5gLCB7IGR1cmF0aW9uIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBhc3NldEJ1aWxkVGltZSA9IG9wdGlvbnMuYXNzZXRCdWlsZFRpbWUgPz8gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgcHJlYnVpbGRBc3NldHMgPSBhc3NldEJ1aWxkVGltZSA9PT0gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IDE7XG5cbiAgICBjb25zdCBzdGFja3NBbmRUaGVpckFzc2V0TWFuaWZlc3RzID0gc3RhY2tzLmZsYXRNYXAoKHN0YWNrKSA9PiBbXG4gICAgICBzdGFjayxcbiAgICAgIC4uLnN0YWNrLmRlcGVuZGVuY2llcy5maWx0ZXIoeCA9PiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoeCkpLFxuICAgIF0pO1xuICAgIGNvbnN0IHdvcmtHcmFwaCA9IG5ldyBXb3JrR3JhcGhCdWlsZGVyKGlvSGVscGVyLCBwcmVidWlsZEFzc2V0cykuYnVpbGQoc3RhY2tzQW5kVGhlaXJBc3NldE1hbmlmZXN0cyk7XG5cbiAgICAvLyBVbmxlc3Mgd2UgYXJlIHJ1bm5pbmcgd2l0aCAnLS1mb3JjZScsIHNraXAgYWxyZWFkeSBwdWJsaXNoZWQgYXNzZXRzXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlQXNzZXRQdWJsaXNoaW5nKSB7XG4gICAgICBhd2FpdCByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoKHdvcmtHcmFwaCwgZGVwbG95bWVudHMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoQ29uY3VycmVuY3k6IENvbmN1cnJlbmN5ID0ge1xuICAgICAgJ3N0YWNrJzogY29uY3VycmVuY3ksXG4gICAgICAnYXNzZXQtYnVpbGQnOiAxLCAvLyBUaGlzIHdpbGwgYmUgQ1BVLWJvdW5kL21lbW9yeSBib3VuZCwgbW9zdGx5IG1hdHRlcnMgZm9yIERvY2tlciBidWlsZHNcbiAgICAgICdhc3NldC1wdWJsaXNoJzogKG9wdGlvbnMuYXNzZXRQYXJhbGxlbGlzbSA/PyB0cnVlKSA/IDggOiAxLCAvLyBUaGlzIHdpbGwgYmUgSS9PLWJvdW5kLCA4IGluIHBhcmFsbGVsIHNlZW1zIHJlYXNvbmFibGVcbiAgICB9O1xuXG4gICAgYXdhaXQgd29ya0dyYXBoLmRvUGFyYWxsZWwoZ3JhcGhDb25jdXJyZW5jeSwge1xuICAgICAgZGVwbG95U3RhY2ssXG4gICAgICBidWlsZEFzc2V0LFxuICAgICAgcHVibGlzaEFzc2V0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaCBBY3Rpb25cbiAgICpcbiAgICogQ29udGludW91c2x5IG9ic2VydmUgcHJvamVjdCBmaWxlcyBhbmQgZGVwbG95IHRoZSBzZWxlY3RlZCBzdGFja3NcbiAgICogYXV0b21hdGljYWxseSB3aGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkLiAgSW1wbGllcyBob3Rzd2FwIGRlcGxveW1lbnRzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHksIHN0YXJ0aW5nIGEgd2F0Y2hlciBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB3YXRjaChjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyk6IFByb21pc2U8SVdhdGNoZXI+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICd3YXRjaCcpO1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCwgZmFsc2UpO1xuICAgIGNvbnN0IHJvb3REaXIgPSBvcHRpb25zLndhdGNoRGlyID8/IHByb2Nlc3MuY3dkKCk7XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5leGNsdWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVzZSB0aGUgJ3dhdGNoJyBjb21tYW5kIHdpdGhvdXQgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgZGlyZWN0b3J5IHRvIG1vbml0b3IuIFwiICtcbiAgICAgICAgICAnTWFrZSBzdXJlIHRvIGFkZCBhIFwid2F0Y2hcIiBrZXkgdG8geW91ciBjZGsuanNvbicsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgXCJpbmNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LCB0aGUgYmVoYXZpb3IgaXM6XG4gICAgLy8gMS4gTm8gXCJ3YXRjaFwiIHNldHRpbmc/IFdlIGVycm9yIG91dC5cbiAgICAvLyAyLiBcIndhdGNoXCIgc2V0dGluZyB3aXRob3V0IGFuIFwiaW5jbHVkZVwiIGtleT8gV2UgZGVmYXVsdCB0byBvYnNlcnZpbmcgXCIuLyoqXCIuXG4gICAgLy8gMy4gXCJ3YXRjaFwiIHNldHRpbmcgd2l0aCBhbiBlbXB0eSBcImluY2x1ZGVcIiBrZXk/IFdlIGRlZmF1bHQgdG8gb2JzZXJ2aW5nIFwiLi8qKlwiLlxuICAgIC8vIDQuIE5vbi1lbXB0eSBcImluY2x1ZGVcIiBrZXk/IEp1c3QgdXNlIHRoZSBcImluY2x1ZGVcIiBrZXkuXG4gICAgY29uc3Qgd2F0Y2hJbmNsdWRlcyA9IHBhdHRlcm5zQXJyYXlGb3JXYXRjaChvcHRpb25zLmluY2x1ZGUsIHtcbiAgICAgIHJvb3REaXIsXG4gICAgICByZXR1cm5Sb290RGlySWZFbXB0eTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIEZvciB0aGUgXCJleGNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBhZGQgc29tZSBkZWZhdWx0IGV4Y2x1ZGVzIGluIGFkZGl0aW9uIHRvIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgdXNlcjpcbiAgICAvLyAxLiBUaGUgQ0RLIG91dHB1dCBkaXJlY3RvcnkuXG4gICAgLy8gMi4gQW55IGZpbGUgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBhIGRvdC5cbiAgICAvLyAzLiBBbnkgZGlyZWN0b3J5J3MgY29udGVudCB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIC8vIDQuIEFueSBub2RlX21vZHVsZXMgYW5kIGl0cyBjb250ZW50IChldmVuIGlmIGl0J3Mgbm90IGEgSlMvVFMgcHJvamVjdCwgeW91IG1pZ2h0IGJlIHVzaW5nIGEgbG9jYWwgYXdzLWNsaSBwYWNrYWdlKVxuICAgIGNvbnN0IG91dGRpciA9IGFzc2VtYmx5LmRpcmVjdG9yeTtcbiAgICBjb25zdCB3YXRjaEV4Y2x1ZGVzID0gcGF0dGVybnNBcnJheUZvcldhdGNoKG9wdGlvbnMuZXhjbHVkZSwge1xuICAgICAgcm9vdERpcixcbiAgICAgIHJldHVyblJvb3REaXJJZkVtcHR5OiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgZXhjbHVkZSB0aGUgb3V0ZGlyIGlmIGl0IGlzIHVuZGVyIHRoZSByb290RGlyXG4gICAgY29uc3QgcmVsYXRpdmVPdXREaXIgPSBwYXRoLnJlbGF0aXZlKHJvb3REaXIsIG91dGRpcik7XG4gICAgaWYgKEJvb2xlYW4ocmVsYXRpdmVPdXREaXIgJiYgIXJlbGF0aXZlT3V0RGlyLnN0YXJ0c1dpdGgoJy4uJyArIHBhdGguc2VwKSAmJiAhcGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlT3V0RGlyKSkpIHtcbiAgICAgIHdhdGNoRXhjbHVkZXMucHVzaChgJHtyZWxhdGl2ZU91dERpcn0vKipgKTtcbiAgICB9XG5cbiAgICB3YXRjaEV4Y2x1ZGVzLnB1c2goJyoqLy4qJywgJyoqLy4qLyoqJywgJyoqL25vZGVfbW9kdWxlcy8qKicpO1xuXG4gICAgLy8gUHJpbnQgc29tZSBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiBjb21wdXRlZCBzZXR0aW5nc1xuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMC5tc2coW1xuICAgICAgYHJvb3QgZGlyZWN0b3J5IHVzZWQgZm9yICd3YXRjaCcgaXM6ICR7cm9vdERpcn1gLFxuICAgICAgYCdpbmNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEluY2x1ZGVzKX1gLFxuICAgICAgYCdleGNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEV4Y2x1ZGVzKX1gLFxuICAgIF0uam9pbignXFxuJyksIHtcbiAgICAgIHdhdGNoRGlyOiByb290RGlyLFxuICAgICAgaW5jbHVkZXM6IHdhdGNoSW5jbHVkZXMsXG4gICAgICBleGNsdWRlczogd2F0Y2hFeGNsdWRlcyxcbiAgICB9KSk7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgICAgICAgIHwgIHJlYWR5IGV2ZW50ICAgfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgcHJlLXJlYWR5ICB8IC0tLS0tLS0tLS0tLS0+IHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG4gICAgdHlwZSBMYXRjaFN0YXRlID0gJ3ByZS1yZWFkeScgfCAnb3BlbicgfCAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnO1xuICAgIGxldCBsYXRjaDogTGF0Y2hTdGF0ZSA9ICdwcmUtcmVhZHknO1xuXG4gICAgY29uc3QgY2xvdWRXYXRjaExvZ01vbml0b3IgPSBvcHRpb25zLnRyYWNlTG9ncyA/IG5ldyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yKHsgaW9IZWxwZXIgfSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGVwbG95QW5kV2F0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnIGFzIExhdGNoU3RhdGU7XG4gICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChhc3NlbWJseSwgb3B0aW9ucywgY2xvdWRXYXRjaExvZ01vbml0b3IpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKGxhdGNoID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycsXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzE1Lm1zZyhcIkRldGVjdGVkIGZpbGUgY2hhbmdlcyBkdXJpbmcgZGVwbG95bWVudC4gSW52b2tpbmcgJ2NkayBkZXBsb3knIGFnYWluXCIpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZva2VEZXBsb3lGcm9tV2F0Y2goYXNzZW1ibHksIG9wdGlvbnMsIGNsb3VkV2F0Y2hMb2dNb25pdG9yKTtcbiAgICAgIH1cbiAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgYXdhaXQgY2xvdWRXYXRjaExvZ01vbml0b3I/LmFjdGl2YXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdhdGNoZXIgPSBjaG9raWRhclxuICAgICAgLndhdGNoKHdhdGNoSW5jbHVkZXMsIHtcbiAgICAgICAgaWdub3JlZDogd2F0Y2hFeGNsdWRlcyxcbiAgICAgICAgY3dkOiByb290RGlyLFxuICAgICAgfSlcbiAgICAgIC5vbigncmVhZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhcIid3YXRjaCcgcmVjZWl2ZWQgdGhlICdyZWFkeScgZXZlbnQuIEZyb20gbm93IG9uLCBhbGwgZmlsZSBjaGFuZ2VzIHdpbGwgdHJpZ2dlciBhIGRlcGxveW1lbnRcIikpO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTQubXNnKFwiVHJpZ2dlcmluZyBpbml0aWFsICdjZGsgZGVwbG95J1wiKSk7XG4gICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdhbGwnLCBhc3luYyAoZXZlbnQ6ICdhZGQnIHwgJ2FkZERpcicgfCAnY2hhbmdlJyB8ICd1bmxpbmsnIHwgJ3VubGlua0RpcicsIGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgd2F0Y2hFdmVudCA9IHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxhdGNoID09PSAncHJlLXJlYWR5Jykge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMS5tc2coYCd3YXRjaCcgaXMgb2JzZXJ2aW5nICR7ZXZlbnQgPT09ICdhZGREaXInID8gJ2RpcmVjdG9yeScgOiAndGhlIGZpbGUnfSAnJHtmaWxlUGF0aH0nIGZvciBjaGFuZ2VzYCwgd2F0Y2hFdmVudCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTIubXNnKGBEZXRlY3RlZCBjaGFuZ2UgdG8gJyR7ZmlsZVBhdGh9JyAodHlwZTogJHtldmVudH0pLiBUcmlnZ2VyaW5nICdjZGsgZGVwbG95J2AsIHdhdGNoRXZlbnQpKTtcbiAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgbGF0Y2ggaXMgZWl0aGVyICdkZXBsb3lpbmcnIG9yICdxdWV1ZWQnXG4gICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTMubXNnKFxuICAgICAgICAgICAgYERldGVjdGVkIGNoYW5nZSB0byAnJHtmaWxlUGF0aH0nICh0eXBlOiAke2V2ZW50fSkgd2hpbGUgJ2NkayBkZXBsb3knIGlzIHN0aWxsIHJ1bm5pbmcuIFdpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcydgLFxuICAgICAgICAgICAgd2F0Y2hFdmVudCxcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjb25zdCBzdG9wcGVkUHJvbWlzZSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgYXdhaXQgd2F0Y2hlci5jbG9zZSgpO1xuICAgICAgICAvLyBQcmV2ZW50cyBOb2RlIGZyb20gc3RheWluZyBhbGl2ZS4gVGhlcmUgaXMgbm8gJ2VuZCcgZXZlbnQgdGhhdCB0aGUgd2F0Y2hlciBlbWl0c1xuICAgICAgICAvLyB0aGF0IHdlIGNhbiBrbm93IGl0J3MgZGVmaW5pdGVseSBkb25lLCBzbyBiZXN0IHdlIGNhbiBkbyBpcyB0ZWxsIGl0IHRvIHN0b3Agd2F0Y2hpbmcsXG4gICAgICAgIC8vIHN0b3Aga2VlcGluZyBOb2RlIGFsaXZlLCBhbmQgdGhlbiBwcmV0ZW5kIHRoYXQncyBldmVyeXRoaW5nIHdlIG5lZWRlZCB0byBkby5cbiAgICAgICAgd2F0Y2hlci51bnJlZigpO1xuICAgICAgICBzdG9wcGVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHdhaXRGb3JFbmQoKSB7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfSxcbiAgICB9IHNhdGlzZmllcyBJV2F0Y2hlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBBY3Rpb25cbiAgICpcbiAgICogUm9sbHMgYmFjayB0aGUgc2VsZWN0ZWQgc3RhY2tzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJvbGxiYWNrKGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogUm9sbGJhY2tPcHRpb25zKTogUHJvbWlzZTxSb2xsYmFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3JvbGxiYWNrJyk7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gdGhpcy5fcm9sbGJhY2soYXNzZW1ibHksICdyb2xsYmFjaycsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhbGxvdyByb2xsYmFjayBiZWluZyBjYWxsZWQgYXMgcGFydCBvZiB0aGUgZGVwbG95IG9yIHdhdGNoIGFjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JvbGxiYWNrKGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBhY3Rpb246ICdyb2xsYmFjaycgfCAnZGVwbG95JyB8ICd3YXRjaCcsIG9wdGlvbnM6IFJvbGxiYWNrT3B0aW9ucyk6IFByb21pc2U8Um9sbGJhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbik7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogb3B0aW9ucy5zdGFja3MgfSk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIob3B0aW9ucy5zdGFja3MpO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3MsIGlvSGVscGVyKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IFJvbGxiYWNrUmVzdWx0ID0ge1xuICAgICAgc3RhY2tzOiBbXSxcbiAgICB9O1xuXG4gICAgaWYgKHN0YWNrcy5zdGFja0NvdW50ID09PSAwKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTYwMDEubXNnKCdObyBzdGFja3Mgc2VsZWN0ZWQnKSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGxldCBhbnlSb2xsYmFja2FibGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW2luZGV4LCBzdGFja10gb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgcm9sbGJhY2tTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlJPTExCQUNLX1NUQUNLKS5iZWdpbihgUm9sbGluZyBiYWNrICR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9YCwge1xuICAgICAgICB0b3RhbDogc3RhY2tzLnN0YWNrQ291bnQsXG4gICAgICAgIGN1cnJlbnQ6IGluZGV4ICsgMSxcbiAgICAgICAgc3RhY2ssXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbigncm9sbGJhY2snKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YWNrUmVzdWx0ID0gYXdhaXQgZGVwbG95bWVudHMucm9sbGJhY2tTdGFjayh7XG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICBvcnBoYW5GYWlsZWRSZXNvdXJjZXM6IG9wdGlvbnMub3JwaGFuRmFpbGVkUmVzb3VyY2VzLFxuICAgICAgICAgIHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICAgIG9ycGhhbkxvZ2ljYWxJZHM6IG9wdGlvbnMub3JwaGFuTG9naWNhbElkcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3RhY2tSZXN1bHQubm90SW5Sb2xsYmFja2FibGVTdGF0ZSkge1xuICAgICAgICAgIGFueVJvbGxiYWNrYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcm9sbGJhY2tTcGFuLmVuZCgpO1xuXG4gICAgICAgIHJldC5zdGFja3MucHVzaCh7XG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgICAgIGFjY291bnQ6IHN0YWNrLmVudmlyb25tZW50LmFjY291bnQsXG4gICAgICAgICAgICByZWdpb246IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIHN0YWNrQXJuOiBzdGFja1Jlc3VsdC5zdGFja0FybixcbiAgICAgICAgICByZXN1bHQ6IHN0YWNrUmVzdWx0Lm5vdEluUm9sbGJhY2thYmxlU3RhdGUgPyAnYWxyZWFkeS1zdGFibGUnIDogJ3JvbGxlZC1iYWNrJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U2OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX0gZmFpbGVkOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignUm9sbGJhY2sgZmFpbGVkICh1c2UgLS1mb3JjZSB0byBvcnBoYW4gZmFpbGluZyByZXNvdXJjZXMpJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYW55Um9sbGJhY2thYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdObyBzdGFja3Mgd2VyZSBpbiBhIHN0YXRlIHRoYXQgY291bGQgYmUgcm9sbGVkIGJhY2snKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgQWN0aW9uXG4gICAqXG4gICAqIERlc3Ryb3lzIHRoZSBzZWxlY3RlZCBTdGFja3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVzdHJveShjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IERlc3Ryb3lPcHRpb25zKTogUHJvbWlzZTxEZXN0cm95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGVzdHJveScpO1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3koYXNzZW1ibHksICdkZXN0cm95Jywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGFsbG93IGRlc3Ryb3kgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIGRlcGxveSBhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9kZXN0cm95KGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBhY3Rpb246ICdkZXBsb3knIHwgJ2Rlc3Ryb3knLCBvcHRpb25zOiBEZXN0cm95T3B0aW9ucyk6IFByb21pc2U8RGVzdHJveVJlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKTtcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBvcHRpb25zLnN0YWNrcyB9KTtcbiAgICAvLyBUaGUgc3RhY2tzIHdpbGwgaGF2ZSBiZWVuIG9yZGVyZWQgZm9yIGRlcGxveW1lbnQsIHNvIHJldmVyc2UgdGhlbSBmb3IgZGVsZXRpb24uXG4gICAgY29uc3Qgc3RhY2tzID0gKGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKG9wdGlvbnMuc3RhY2tzKSkucmV2ZXJzZWQoKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IERlc3Ryb3lSZXN1bHQgPSB7XG4gICAgICBzdGFja3M6IFtdLFxuICAgIH07XG5cbiAgICBjb25zdCBtb3RpdmF0aW9uID0gJ0Rlc3Ryb3lpbmcgc3RhY2tzIGlzIGFuIGlycmV2ZXJzaWJsZSBhY3Rpb24nO1xuICAgIGNvbnN0IHF1ZXN0aW9uID0gYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGU6ICR7Y2hhbGsucmVkKHN0YWNrcy5oaWVyYXJjaGljYWxJZHMuam9pbignLCAnKSl9YDtcbiAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBpb0hlbHBlci5yZXF1ZXN0UmVzcG9uc2UoSU8uQ0RLX1RPT0xLSVRfSTcwMTAucmVxKHF1ZXN0aW9uLCB7IG1vdGl2YXRpb24gfSkpO1xuICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTcwMTAubXNnKCdBYm9ydGVkIGJ5IHVzZXInKSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNvbnN0IGRlc3Ryb3lTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRFU1RST1lfQUNUSU9OKS5iZWdpbih7XG4gICAgICBzdGFja3M6IHN0YWNrcy5zdGFja0FydGlmYWN0cyxcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHN0YWNrXSBvZiBzdGFja3Muc3RhY2tBcnRpZmFjdHMuZW50cmllcygpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2luZ2xlRGVzdHJveVNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uREVTVFJPWV9TVEFDSylcbiAgICAgICAgICAgIC5iZWdpbihjaGFsay5ncmVlbihgJHtjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKX06IGRlc3Ryb3lpbmcuLi4gWyR7aW5kZXggKyAxfS8ke3N0YWNrcy5zdGFja0NvdW50fV1gKSwge1xuICAgICAgICAgICAgICB0b3RhbDogc3RhY2tzLnN0YWNrQ291bnQsXG4gICAgICAgICAgICAgIGN1cnJlbnQ6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZXBsb3ltZW50cy5kZXN0cm95U3RhY2soe1xuICAgICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgICBkZXBsb3lOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXQuc3RhY2tzLnB1c2goe1xuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgICAgICAgYWNjb3VudDogc3RhY2suZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgICAgICAgICAgcmVnaW9uOiBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhY2tOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgICBzdGFja0FybjogcmVzdWx0LnN0YWNrQXJuLFxuICAgICAgICAgICAgc3RhY2tFeGlzdGVkOiByZXN1bHQuc3RhY2tBcm4gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNzkwMC5tc2coY2hhbGsuZ3JlZW4oYFxcbiDinIUgICR7Y2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSl9OiAke2FjdGlvbn1lZGApLCBzdGFjaykpO1xuICAgICAgICAgIGF3YWl0IHNpbmdsZURlc3Ryb3lTcGFuLmVuZCgpO1xuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTc5MDAubXNnKGBcXG4g4p2MICAke2NoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpfTogJHthY3Rpb259IGZhaWxlZCAke2V9YCwgeyBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBkZXN0cm95U3Bhbi5lbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIHN0YWNrcyBmb3IgZXJyb3JzIGFuZCB3YXJuaW5ncyBhY2NvcmRpbmcgdG8gdGhlIENMSSdzIGN1cnJlbnQgc2V0dGluZ3NcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3M6IFN0YWNrQ29sbGVjdGlvbiwgaW9Ib3N0OiBJb0hlbHBlcikge1xuICAgIGNvbnN0IGJ1aWxkZXIgPSAobGV2ZWw6IElvTWVzc2FnZUxldmVsKSA9PiB7XG4gICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzogcmV0dXJuIElPLkNES19BU1NFTUJMWV9FOTk5OTtcbiAgICAgICAgY2FzZSAnd2Fybic6IHJldHVybiBJTy5DREtfQVNTRU1CTFlfVzk5OTk7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBJTy5DREtfQVNTRU1CTFlfSTk5OTk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhd2FpdCBzdGFja3MudmFsaWRhdGVNZXRhZGF0YShcbiAgICAgIHRoaXMucHJvcHMuYXNzZW1ibHlGYWlsdXJlQXQsXG4gICAgICBhc3luYyAobGV2ZWwsIG1zZykgPT4gaW9Ib3N0Lm5vdGlmeShidWlsZGVyKGxldmVsKS5tc2coYFske2xldmVsfSBhdCAke21zZy5pZH1dICR7bXNnLmVudHJ5LmRhdGF9YCwgbXNnKSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZXBsb3ltZW50cyBjbGFzc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZXBsb3ltZW50c0ZvckFjdGlvbihhY3Rpb246IFRvb2xraXRBY3Rpb24pOiBQcm9taXNlPERlcGxveW1lbnRzPiB7XG4gICAgcmV0dXJuIG5ldyBEZXBsb3ltZW50cyh7XG4gICAgICBzZGtQcm92aWRlcjogYXdhaXQgdGhpcy5zZGtQcm92aWRlcihhY3Rpb24pLFxuICAgICAgdG9vbGtpdFN0YWNrTmFtZTogdGhpcy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgaW9IZWxwZXI6IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbiksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGludm9rZURlcGxveUZyb21XYXRjaChcbiAgICBhc3NlbWJseTogU3RhY2tBc3NlbWJseSxcbiAgICBvcHRpb25zOiBXYXRjaE9wdGlvbnMsXG4gICAgY2xvdWRXYXRjaExvZ01vbml0b3I/OiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyB3YXRjaCBkZWZhdWx0cyBob3Rzd2FwIHRvIGVuYWJsZWRcbiAgICBjb25zdCBob3Rzd2FwID0gb3B0aW9ucy5ob3Rzd2FwID8/IEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWTtcbiAgICBjb25zdCBkZXBsb3lPcHRpb25zOiBFeHRlbmRlZERlcGxveU9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2xvdWRXYXRjaExvZ01vbml0b3IsXG4gICAgICBob3Rzd2FwLFxuICAgICAgZXh0cmFVc2VyQWdlbnQ6IGBjZGstd2F0Y2gvaG90c3dhcC0ke2hvdHN3YXAgPT09IEhvdHN3YXBNb2RlLkZVTExfREVQTE9ZTUVOVCA/ICdvZmYnIDogJ29uJ31gLFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fZGVwbG95KGFzc2VtYmx5LCAnd2F0Y2gnLCBkZXBsb3lPcHRpb25zKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGp1c3QgY29udGludWUgLSBkZXBsb3kgd2lsbCBzaG93IHRoZSBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXN1bHQgb2YgYSBgY2RrLndhdGNoKClgIG9wZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJV2F0Y2hlciBleHRlbmRzIEFzeW5jRGlzcG9zYWJsZSB7XG4gIC8qKlxuICAgKiBTdG9wIHRoZSB3YXRjaGVyIGFuZCB3YWl0IGZvciB0aGUgY3VycmVudCB3YXRjaCBpdGVyYXRpb24gdG8gY29tcGxldGUuXG4gICAqXG4gICAqIEFuIGFsaWFzIGZvciBgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdYCwgYXMgYSBtb3JlIHJlYWRhYmxlIGFsdGVybmF0aXZlIGZvclxuICAgKiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBEaXNwb3NhYmxlIEFQSXMgeWV0LlxuICAgKi9cbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBXYWl0IGZvciB0aGUgd2F0Y2hlciB0byBzdG9wLlxuICAgKlxuICAgKiBUaGUgd2F0Y2hlciB3aWxsIG9ubHkgc3RvcCBpZiBgZGlzcG9zZSgpYCBvciBgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKClgIGFyZSBjYWxsZWQuXG4gICAqXG4gICAqIElmIG5laXRoZXIgb2YgdGhvc2UgaXMgY2FsbGVkLCBhd2FpdGluZyB0aGlzIHByb21pc2Ugd2lsbCB3YWl0IGZvcmV2ZXIuXG4gICAqL1xuICB3YWl0Rm9yRW5kKCk6IFByb21pc2U8dm9pZD47XG59XG4iXX0=