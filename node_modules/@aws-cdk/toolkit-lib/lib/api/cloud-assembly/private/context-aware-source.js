"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContextAwareCloudAssembly = void 0;
const private_1 = require("../../io/private");
const shared_private_1 = require("../../shared-private");
const shared_private_2 = require("../../shared-private");
const shared_public_1 = require("../../shared-public");
/**
 * Represent the Cloud Executable and the synthesis we can do on it
 */
class ContextAwareCloudAssembly {
    source;
    props;
    canLookup;
    context;
    contextFile;
    ioHelper;
    constructor(source, props) {
        this.source = source;
        this.props = props;
        this.canLookup = props.lookups ?? true;
        this.context = props.context;
        this.contextFile = props.contextFile ?? shared_private_2.PROJECT_CONTEXT; // @todo new feature not needed right now
        this.ioHelper = props.services.ioHelper;
    }
    /**
     * Produce a Cloud Assembly, i.e. a set of stacks
     */
    async produce() {
        // We may need to run the cloud assembly source multiple times in order to satisfy all missing context
        // (When the source producer runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.source.produce();
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeysSet = missingContextKeys(assembly.manifest.missing);
                const missingKeys = Array.from(missingKeysSet);
                if (!this.canLookup) {
                    throw new shared_public_1.ToolkitError('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${missingKeys.join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && equalSets(missingKeysSet, previouslyMissingKeys)) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0240.msg('Not making progress trying to resolve environmental context. Giving up.', { missingKeys }));
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeysSet;
                if (tryLookup) {
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0241.msg('Some context information is missing. Fetching...', { missingKeys }));
                    await shared_private_1.contextproviders.provideContextValues(assembly.manifest.missing, this.context, this.props.services.sdkProvider, this.ioHelper);
                    // Cache the new context to disk
                    await this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0042.msg(`Writing updated context to ${this.contextFile}...`, {
                        contextFile: this.contextFile,
                        context: this.context.all,
                    }));
                    await this.context.save(this.contextFile);
                    // Execute again
                    continue;
                }
            }
            return assembly;
        }
    }
}
exports.ContextAwareCloudAssembly = ContextAwareCloudAssembly;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
/**
 * Are two sets equal to each other
 */
function equalSets(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1hd2FyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb250ZXh0LWF3YXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSw4Q0FBc0M7QUFDdEMseURBQXdEO0FBQ3hELHlEQUFvRjtBQUNwRix1REFBbUQ7QUFnQ25EOztHQUVHO0FBQ0gsTUFBYSx5QkFBeUI7SUFNUDtJQUErQztJQUxwRSxTQUFTLENBQVU7SUFDbkIsT0FBTyxDQUFVO0lBQ2pCLFdBQVcsQ0FBUztJQUNwQixRQUFRLENBQVc7SUFFM0IsWUFBNkIsTUFBNEIsRUFBbUIsS0FBcUM7UUFBcEYsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7UUFBbUIsVUFBSyxHQUFMLEtBQUssQ0FBZ0M7UUFDL0csSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQztRQUN2QyxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLGdDQUFlLENBQUMsQ0FBQyx5Q0FBeUM7UUFDbEcsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsT0FBTztRQUNsQixzR0FBc0c7UUFDdEcsZ0ZBQWdGO1FBQ2hGLG1GQUFtRjtRQUNuRiw4RUFBOEU7UUFDOUUsSUFBSSxxQkFBOEMsQ0FBQztRQUNuRCxPQUFPLElBQUksRUFBRSxDQUFDO1lBQ1osTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRTdDLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUN0RSxNQUFNLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNyRSxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUUvQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUNwQixNQUFNLElBQUksNEJBQVksQ0FDcEIsc0NBQXNDOzBCQUNwQyxzS0FBc0s7MEJBQ3RLLDBCQUEwQixXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDM0QsQ0FBQztnQkFFRCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ3JCLElBQUkscUJBQXFCLElBQUksU0FBUyxDQUFDLGNBQWMsRUFBRSxxQkFBcUIsQ0FBQyxFQUFFLENBQUM7b0JBQzlFLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyx5RUFBeUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDbEosU0FBUyxHQUFHLEtBQUssQ0FBQztnQkFDcEIsQ0FBQztnQkFFRCxxQkFBcUIsR0FBRyxjQUFjLENBQUM7Z0JBRXZDLElBQUksU0FBUyxFQUFFLENBQUM7b0JBQ2QsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLGtEQUFrRCxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMzSCxNQUFNLGlDQUFnQixDQUFDLG9CQUFvQixDQUN6QyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFDekIsSUFBSSxDQUFDLE9BQU8sRUFDWixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQy9CLElBQUksQ0FBQyxRQUFRLENBQ2QsQ0FBQztvQkFFRixnQ0FBZ0M7b0JBQ2hDLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyw4QkFBOEIsSUFBSSxDQUFDLFdBQVcsS0FBSyxFQUFFO3dCQUN4RyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7d0JBQzdCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUc7cUJBQzFCLENBQUMsQ0FBQyxDQUFDO29CQUNKLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUUxQyxnQkFBZ0I7b0JBQ2hCLFNBQVM7Z0JBQ1gsQ0FBQztZQUNILENBQUM7WUFFRCxPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBcEVELDhEQW9FQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxPQUEwQjtJQUNwRCxPQUFPLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsU0FBUyxDQUFJLENBQVMsRUFBRSxDQUFTO0lBQ3hDLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdEIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTWlzc2luZ0NvbnRleHQgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0U2VydmljZXMgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3ByaXZhdGUnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi8uLi9pby9wcml2YXRlJztcbmltcG9ydCB7IGNvbnRleHRwcm92aWRlcnMgfSBmcm9tICcuLi8uLi9zaGFyZWQtcHJpdmF0ZSc7XG5pbXBvcnQgeyBQUk9KRUNUX0NPTlRFWFQsIHR5cGUgQ29udGV4dCwgdHlwZSBJb0hlbHBlciB9IGZyb20gJy4uLy4uL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC1wdWJsaWMnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5UHJvcHMge1xuICAvKipcbiAgICogQVdTIG9iamVjdCAodXNlZCBieSBjb250ZXh0cHJvdmlkZXIpXG4gICAqIEBkZXByZWNhdGVkIGNvbnRleHQgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSB0b29sa2l0IGl0c2VsZlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZXM6IFRvb2xraXRTZXJ2aWNlcztcblxuICAvKipcbiAgICogQXBwbGljYXRpb24gY29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dDogQ29udGV4dDtcblxuICAvKipcbiAgICogVGhlIGZpbGUgdXNlZCB0byBzdG9yZSBhcHBsaWNhdGlvbiBjb250ZXh0IGluIChyZWxhdGl2ZSB0byBjd2QpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBcImNkay5jb250ZXh0Lmpzb25cIlxuICAgKi9cbiAgcmVhZG9ubHkgY29udGV4dEZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBjb250ZXh0IGxvb2t1cHMuXG4gICAqXG4gICAqIFByb2R1Y2luZyBhIGBjeGFwaS5DbG91ZEFzc2VtYmx5YCB3aWxsIGZhaWwgaWYgdGhpcyBpcyBkaXNhYmxlZCBhbmQgY29udGV4dCBsb29rdXBzIG5lZWQgdG8gYmUgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBsb29rdXBzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgdGhlIENsb3VkIEV4ZWN1dGFibGUgYW5kIHRoZSBzeW50aGVzaXMgd2UgY2FuIGRvIG9uIGl0XG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZXh0QXdhcmVDbG91ZEFzc2VtYmx5IGltcGxlbWVudHMgSUNsb3VkQXNzZW1ibHlTb3VyY2Uge1xuICBwcml2YXRlIGNhbkxvb2t1cDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBjb250ZXh0OiBDb250ZXh0O1xuICBwcml2YXRlIGNvbnRleHRGaWxlOiBzdHJpbmc7XG4gIHByaXZhdGUgaW9IZWxwZXI6IElvSGVscGVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc291cmNlOiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgcHJpdmF0ZSByZWFkb25seSBwcm9wczogQ29udGV4dEF3YXJlQ2xvdWRBc3NlbWJseVByb3BzKSB7XG4gICAgdGhpcy5jYW5Mb29rdXAgPSBwcm9wcy5sb29rdXBzID8/IHRydWU7XG4gICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHRGaWxlID0gcHJvcHMuY29udGV4dEZpbGUgPz8gUFJPSkVDVF9DT05URVhUOyAvLyBAdG9kbyBuZXcgZmVhdHVyZSBub3QgbmVlZGVkIHJpZ2h0IG5vd1xuICAgIHRoaXMuaW9IZWxwZXIgPSBwcm9wcy5zZXJ2aWNlcy5pb0hlbHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIGEgQ2xvdWQgQXNzZW1ibHksIGkuZS4gYSBzZXQgb2Ygc3RhY2tzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHJvZHVjZSgpOiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+IHtcbiAgICAvLyBXZSBtYXkgbmVlZCB0byBydW4gdGhlIGNsb3VkIGFzc2VtYmx5IHNvdXJjZSBtdWx0aXBsZSB0aW1lcyBpbiBvcmRlciB0byBzYXRpc2Z5IGFsbCBtaXNzaW5nIGNvbnRleHRcbiAgICAvLyAoV2hlbiB0aGUgc291cmNlIHByb2R1Y2VyIHJ1bnMsIGl0IHdpbGwgdGVsbCB1cyBhYm91dCBjb250ZXh0IGl0IHdhbnRzIHRvIHVzZVxuICAgIC8vIGJ1dCBpdCBtaXNzaW5nLiBXZSdsbCB0aGVuIGxvb2sgdXAgdGhlIGNvbnRleHQgYW5kIHJ1biB0aGUgZXhlY3V0YWJsZSBhZ2FpbiwgYW5kXG4gICAgLy8gYWdhaW4sIHVudGlsIGl0IGRvZXNuJ3QgY29tcGxhaW4gYW55bW9yZSBvciB3ZSd2ZSBzdG9wcGVkIG1ha2luZyBwcm9ncmVzcykuXG4gICAgbGV0IHByZXZpb3VzbHlNaXNzaW5nS2V5czogU2V0PHN0cmluZz4gfCB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgdGhpcy5zb3VyY2UucHJvZHVjZSgpO1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyAmJiBhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ0tleXNTZXQgPSBtaXNzaW5nQ29udGV4dEtleXMoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyk7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gQXJyYXkuZnJvbShtaXNzaW5nS2V5c1NldCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbkxvb2t1cCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICAgICAnQ29udGV4dCBsb29rdXBzIGhhdmUgYmVlbiBkaXNhYmxlZC4gJ1xuICAgICAgICAgICAgKyAnTWFrZSBzdXJlIGFsbCBuZWNlc3NhcnkgY29udGV4dCBpcyBhbHJlYWR5IGluIFxcJ2Nkay5jb250ZXh0Lmpzb25cXCcgYnkgcnVubmluZyBcXCdjZGsgc3ludGhcXCcgb24gYSBtYWNoaW5lIHdpdGggc3VmZmljaWVudCBBV1MgY3JlZGVudGlhbHMgYW5kIGNvbW1pdHRpbmcgdGhlIHJlc3VsdC4gJ1xuICAgICAgICAgICAgKyBgTWlzc2luZyBjb250ZXh0IGtleXM6ICcke21pc3NpbmdLZXlzLmpvaW4oJywgJyl9J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRyeUxvb2t1cCA9IHRydWU7XG4gICAgICAgIGlmIChwcmV2aW91c2x5TWlzc2luZ0tleXMgJiYgZXF1YWxTZXRzKG1pc3NpbmdLZXlzU2V0LCBwcmV2aW91c2x5TWlzc2luZ0tleXMpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0kwMjQwLm1zZygnTm90IG1ha2luZyBwcm9ncmVzcyB0cnlpbmcgdG8gcmVzb2x2ZSBlbnZpcm9ubWVudGFsIGNvbnRleHQuIEdpdmluZyB1cC4nLCB7IG1pc3NpbmdLZXlzIH0pKTtcbiAgICAgICAgICB0cnlMb29rdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzbHlNaXNzaW5nS2V5cyA9IG1pc3NpbmdLZXlzU2V0O1xuXG4gICAgICAgIGlmICh0cnlMb29rdXApIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTAyNDEubXNnKCdTb21lIGNvbnRleHQgaW5mb3JtYXRpb24gaXMgbWlzc2luZy4gRmV0Y2hpbmcuLi4nLCB7IG1pc3NpbmdLZXlzIH0pKTtcbiAgICAgICAgICBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKFxuICAgICAgICAgICAgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc2VydmljZXMuc2RrUHJvdmlkZXIsXG4gICAgICAgICAgICB0aGlzLmlvSGVscGVyLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IGNvbnRleHQgdG8gZGlza1xuICAgICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9JMDA0Mi5tc2coYFdyaXRpbmcgdXBkYXRlZCBjb250ZXh0IHRvICR7dGhpcy5jb250ZXh0RmlsZX0uLi5gLCB7XG4gICAgICAgICAgICBjb250ZXh0RmlsZTogdGhpcy5jb250ZXh0RmlsZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dC5hbGwsXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuY29udGV4dC5zYXZlKHRoaXMuY29udGV4dEZpbGUpO1xuXG4gICAgICAgICAgLy8gRXhlY3V0ZSBhZ2FpblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc3NlbWJseTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGtleXMgb2YgbWlzc2luZyBjb250ZXh0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIG1pc3NpbmdDb250ZXh0S2V5cyhtaXNzaW5nPzogTWlzc2luZ0NvbnRleHRbXSk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQoKG1pc3NpbmcgfHwgW10pLm1hcChtID0+IG0ua2V5KSk7XG59XG5cbi8qKlxuICogQXJlIHR3byBzZXRzIGVxdWFsIHRvIGVhY2ggb3RoZXJcbiAqL1xuZnVuY3Rpb24gZXF1YWxTZXRzPEE+KGE6IFNldDxBPiwgYjogU2V0PEE+KSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IHggb2YgYSkge1xuICAgIGlmICghYi5oYXMoeCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=