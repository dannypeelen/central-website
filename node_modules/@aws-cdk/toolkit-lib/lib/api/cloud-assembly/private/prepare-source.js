"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionEnvironment = void 0;
exports.assemblyFromDirectory = assemblyFromDirectory;
const os = require("node:os");
const path = require("node:path");
const node_util_1 = require("node:util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver_1 = require("semver");
const shared_private_1 = require("../../../api/shared-private");
const shared_private_2 = require("../../../api/shared-private");
const util_1 = require("../../../private/util");
const private_1 = require("../../io/private");
const shared_public_1 = require("../../shared-public");
class ExecutionEnvironment {
    ioHelper;
    sdkProvider;
    debugFn;
    _outdir;
    constructor(services, props = {}) {
        this.ioHelper = services.ioHelper;
        this.sdkProvider = services.sdkProvider;
        this.debugFn = (msg) => this.ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg(msg));
        this._outdir = props.outdir;
    }
    /**
     * Turn the given optional output directory into a fixed output directory
     */
    get outdir() {
        if (!this._outdir) {
            const outdir = fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));
            this._outdir = outdir;
        }
        return this._outdir;
    }
    /**
     * Guess the executable from the command-line argument
     *
     * Only do this if the file is NOT marked as executable. If it is,
     * we'll defer to the shebang inside the file itself.
     *
     * If we're on Windows, we ALWAYS take the handler, since it's hard to
     * verify if registry associations have or have not been set up for this
     * file type, so we'll assume the worst and take control.
     */
    guessExecutable(app) {
        return (0, shared_private_1.guessExecutable)(app, this.debugFn);
    }
    /**
     * If we don't have region/account defined in context, we fall back to the default SDK behavior
     * where region is retrieved from ~/.aws/config and account is based on default credentials provider
     * chain and then STS is queried.
     *
     * This is done opportunistically: for example, if we can't access STS for some reason or the region
     * is not configured, the context value will be 'null' and there could failures down the line. In
     * some cases, synthesis does not require region/account information at all, so that might be perfectly
     * fine in certain scenarios.
     */
    async defaultEnvVars() {
        const debugFn = (msg) => this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0010.msg(msg));
        const env = await (0, shared_private_1.prepareDefaultEnvironment)(this.sdkProvider, debugFn);
        env[cxapi.OUTDIR_ENV] = this.outdir;
        await debugFn((0, node_util_1.format)('outdir:', this.outdir));
        // CLI version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, util_1.versionNumber)();
        await debugFn((0, node_util_1.format)('env:', env));
        return env;
    }
    /**
     * Run code from a different working directory
     */
    async changeDir(block, workingDir) {
        const originalWorkingDir = process.cwd();
        try {
            if (workingDir) {
                process.chdir(workingDir);
            }
            return await block();
        }
        finally {
            if (workingDir) {
                process.chdir(originalWorkingDir);
            }
        }
    }
    /**
     * Run code with additional environment variables
     */
    async withEnv(env = {}, block) {
        const originalEnv = process.env;
        try {
            process.env = {
                ...originalEnv,
                ...env,
            };
            return await block();
        }
        finally {
            process.env = originalEnv;
        }
    }
    /**
     * Run code with context setup inside the environment
     */
    async withContext(inputContext, env, synthOpts = {}, block) {
        const context = await (0, shared_private_1.prepareContext)(synthOptsDefaults(synthOpts), inputContext, env, this.debugFn);
        let contextOverflowLocation = null;
        try {
            const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
            const [smallContext, overflow] = (0, util_1.splitBySize)(context, (0, shared_private_1.spaceAvailableForContext)(env, envVariableSizeLimit));
            // Store the safe part in the environment variable
            env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
            // If there was any overflow, write it to a temporary file
            if (Object.keys(overflow ?? {}).length > 0) {
                const contextDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk-context'));
                contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
                fs.writeJSONSync(contextOverflowLocation, overflow);
                env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
            }
            // call the block code with new environment
            return await block(env, context);
        }
        finally {
            if (contextOverflowLocation) {
                fs.removeSync(path.dirname(contextOverflowLocation));
            }
        }
    }
}
exports.ExecutionEnvironment = ExecutionEnvironment;
/**
 * Checks if a given assembly supports context overflow, warn otherwise.
 *
 * @param assembly the assembly to check
 */
async function checkContextOverflowSupport(assembly, ioHelper) {
    const traceFn = (msg) => ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_TRACE.msg(msg));
    const tree = await (0, shared_private_2.loadTree)(assembly, traceFn);
    const frameworkDoesNotSupportContextOverflow = (0, shared_private_2.some)(tree, node => {
        const fqn = node.constructInfo?.fqn;
        const version = node.constructInfo?.version;
        return (fqn === 'aws-cdk-lib.App' && version != null && (0, semver_1.lte)(version, '2.38.0')) // v2
            || fqn === '@aws-cdk/core.App'; // v1
    });
    // We're dealing with an old version of the framework here. It is unaware of the temporary
    // file, which means that it will ignore the context overflow.
    if (frameworkDoesNotSupportContextOverflow) {
        await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_W0010.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
    }
}
/**
 * Safely create an assembly from a cloud assembly directory
 */
async function assemblyFromDirectory(assemblyDir, ioHelper, loadOptions = {}) {
    try {
        const assembly = new cxapi.CloudAssembly(assemblyDir, {
            skipVersionCheck: !(loadOptions.checkVersion ?? true),
            skipEnumCheck: !(loadOptions.checkEnums ?? true),
            // We sort as we deploy
            topoSort: false,
        });
        await checkContextOverflowSupport(assembly, ioHelper);
        return assembly;
    }
    catch (err) {
        if (err.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            const message = 'This AWS CDK Toolkit is not compatible with the AWS CDK library used by your application. Please upgrade to the latest version.';
            await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1111.msg(message, { error: err }));
            throw new shared_public_1.ToolkitError(`${message}\n(${err.message}`);
        }
        throw err;
    }
}
function synthOptsDefaults(synthOpts = {}) {
    return new shared_private_2.Settings({
        debug: false,
        pathMetadata: true,
        versionReporting: true,
        assetMetadata: true,
        assetStaging: true,
        ...synthOpts,
    }, true);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcGFyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcmVwYXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFrTEEsc0RBb0JDO0FBdE1ELDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMseUNBQW1DO0FBQ25DLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLG1DQUE2QjtBQUM3QixnRUFBaUo7QUFDakosZ0VBQXdHO0FBQ3hHLGdEQUFtRTtBQUVuRSw4Q0FBc0M7QUFDdEMsdURBQW1EO0FBTW5ELE1BQWEsb0JBQW9CO0lBQ2QsUUFBUSxDQUFXO0lBQ25CLFdBQVcsQ0FBYztJQUN6QixPQUFPLENBQWlDO0lBQ2pELE9BQU8sQ0FBcUI7SUFFcEMsWUFBbUIsUUFBeUIsRUFBRSxRQUE2QixFQUFFO1FBQzNFLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDeEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUM5QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLE1BQU07UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2xCLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDbEYsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDeEIsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksZUFBZSxDQUFDLEdBQVc7UUFDaEMsT0FBTyxJQUFBLGdDQUFlLEVBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksS0FBSyxDQUFDLGNBQWM7UUFDekIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0RixNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUEsMENBQVUsRUFBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXhELEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNwQyxNQUFNLE9BQU8sQ0FBQyxJQUFBLGtCQUFNLEVBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBRTlDLDBCQUEwQjtRQUMxQixHQUFHLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM3RCxHQUFHLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxHQUFHLElBQUEsb0JBQWEsR0FBRSxDQUFDO1FBRTdDLE1BQU0sT0FBTyxDQUFDLElBQUEsa0JBQU0sRUFBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQyxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQUksS0FBdUIsRUFBRSxVQUFtQjtRQUNwRSxNQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUM7WUFDSCxJQUFJLFVBQVUsRUFBRSxDQUFDO2dCQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDNUIsQ0FBQztZQUVELE9BQU8sTUFBTSxLQUFLLEVBQUUsQ0FBQztRQUN2QixDQUFDO2dCQUFTLENBQUM7WUFDVCxJQUFJLFVBQVUsRUFBRSxDQUFDO2dCQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztZQUNwQyxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxPQUFPLENBQUksTUFBVyxFQUFFLEVBQUUsS0FBdUI7UUFDNUQsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUNoQyxJQUFJLENBQUM7WUFDSCxPQUFPLENBQUMsR0FBRyxHQUFHO2dCQUNaLEdBQUcsV0FBVztnQkFDZCxHQUFHLEdBQUc7YUFDUCxDQUFDO1lBRUYsT0FBTyxNQUFNLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLENBQUM7Z0JBQVMsQ0FBQztZQUNULE9BQU8sQ0FBQyxHQUFHLEdBQUcsV0FBVyxDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsV0FBVyxDQUN0QixZQUFxQixFQUNyQixHQUFRLEVBQ1IsWUFBNkIsRUFBRSxFQUMvQixLQUFpRDtRQUVqRCxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUEsK0JBQWMsRUFBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNwRyxJQUFJLHVCQUF1QixHQUFHLElBQUksQ0FBQztRQUVuQyxJQUFJLENBQUM7WUFDSCxNQUFNLG9CQUFvQixHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ3hFLE1BQU0sQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLEdBQUcsSUFBQSxrQkFBVyxFQUFDLE9BQU8sRUFBRSxJQUFBLHlDQUF3QixFQUFDLEdBQUcsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7WUFFM0csa0RBQWtEO1lBQ2xELEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUV0RCwwREFBMEQ7WUFDMUQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQzNDLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDekUsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztnQkFDekUsRUFBRSxDQUFDLGFBQWEsQ0FBQyx1QkFBdUIsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDcEQsR0FBRyxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxHQUFHLHVCQUF1QixDQUFDO1lBQ3JFLENBQUM7WUFFRCwyQ0FBMkM7WUFDM0MsT0FBTyxNQUFNLEtBQUssQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDbkMsQ0FBQztnQkFBUyxDQUFDO1lBQ1QsSUFBSSx1QkFBdUIsRUFBRSxDQUFDO2dCQUM1QixFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBcklELG9EQXFJQztBQUVEOzs7O0dBSUc7QUFDSCxLQUFLLFVBQVUsMkJBQTJCLENBQUMsUUFBNkIsRUFBRSxRQUFrQjtJQUMxRixNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckYsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFBLHlCQUFRLEVBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQy9DLE1BQU0sc0NBQXNDLEdBQUcsSUFBQSxxQkFBSSxFQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRTtRQUMvRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQztRQUM1QyxPQUFPLENBQUMsR0FBRyxLQUFLLGlCQUFpQixJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksSUFBQSxZQUFHLEVBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSztlQUNsRixHQUFHLEtBQUssbUJBQW1CLENBQUMsQ0FBQyxLQUFLO0lBQ3ZDLENBQUMsQ0FBQyxDQUFDO0lBRUgsMEZBQTBGO0lBQzFGLDhEQUE4RDtJQUM5RCxJQUFJLHNDQUFzQyxFQUFFLENBQUM7UUFDM0MsTUFBTSxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsb0hBQW9ILENBQUMsQ0FBQyxDQUFDO0lBQ3pLLENBQUM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSSxLQUFLLFVBQVUscUJBQXFCLENBQUMsV0FBbUIsRUFBRSxRQUFrQixFQUFFLGNBQW1DLEVBQUU7SUFDeEgsSUFBSSxDQUFDO1FBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRTtZQUNwRCxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUM7WUFDckQsYUFBYSxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQztZQUNoRCx1QkFBdUI7WUFDdkIsUUFBUSxFQUFFLEtBQUs7U0FDaEIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSwyQkFBMkIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEQsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUFDLE9BQU8sR0FBUSxFQUFFLENBQUM7UUFDbEIsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQ3BELHlDQUF5QztZQUN6QyxtQ0FBbUM7WUFDbkMsTUFBTSxPQUFPLEdBQUcsaUlBQWlJLENBQUM7WUFDbEosTUFBTSxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMxRSxNQUFNLElBQUksNEJBQVksQ0FBQyxHQUFHLE9BQU8sTUFBTSxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUN4RCxDQUFDO1FBQ0QsTUFBTSxHQUFHLENBQUM7SUFDWixDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUMsWUFBNkIsRUFBRTtJQUN4RCxPQUFPLElBQUkseUJBQVEsQ0FBQztRQUNsQixLQUFLLEVBQUUsS0FBSztRQUNaLFlBQVksRUFBRSxJQUFJO1FBQ2xCLGdCQUFnQixFQUFFLElBQUk7UUFDdEIsYUFBYSxFQUFFLElBQUk7UUFDbkIsWUFBWSxFQUFFLElBQUk7UUFDbEIsR0FBRyxTQUFTO0tBQ2IsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNYLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdub2RlOm9zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGx0ZSB9IGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBwcmVwYXJlRGVmYXVsdEVudmlyb25tZW50IGFzIG9sZFByZXBhcmUsIHByZXBhcmVDb250ZXh0LCBzcGFjZUF2YWlsYWJsZUZvckNvbnRleHQsIGd1ZXNzRXhlY3V0YWJsZSB9IGZyb20gJy4uLy4uLy4uL2FwaS9zaGFyZWQtcHJpdmF0ZSc7XG5pbXBvcnQgeyB0eXBlIFNka1Byb3ZpZGVyLCB0eXBlIElvSGVscGVyLCBsb2FkVHJlZSwgc29tZSwgU2V0dGluZ3MgfSBmcm9tICcuLi8uLi8uLi9hcGkvc2hhcmVkLXByaXZhdGUnO1xuaW1wb3J0IHsgc3BsaXRCeVNpemUsIHZlcnNpb25OdW1iZXIgfSBmcm9tICcuLi8uLi8uLi9wcml2YXRlL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBUb29sa2l0U2VydmljZXMgfSBmcm9tICcuLi8uLi8uLi90b29sa2l0L3ByaXZhdGUnO1xuaW1wb3J0IHsgSU8gfSBmcm9tICcuLi8uLi9pby9wcml2YXRlJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC1wdWJsaWMnO1xuaW1wb3J0IHR5cGUgeyBBcHBTeW50aE9wdGlvbnMsIExvYWRBc3NlbWJseU9wdGlvbnMgfSBmcm9tICcuLi9zb3VyY2UtYnVpbGRlcic7XG5cbnR5cGUgRW52ID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbnR5cGUgQ29udGV4dCA9IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbmV4cG9ydCBjbGFzcyBFeGVjdXRpb25FbnZpcm9ubWVudCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWJ1Z0ZuOiAobXNnOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgX291dGRpcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzLCBwcm9wczogeyBvdXRkaXI/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgdGhpcy5pb0hlbHBlciA9IHNlcnZpY2VzLmlvSGVscGVyO1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBzZXJ2aWNlcy5zZGtQcm92aWRlcjtcbiAgICB0aGlzLmRlYnVnRm4gPSAobXNnOiBzdHJpbmcpID0+IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfQVNTRU1CTFlfREVCVUcubXNnKG1zZykpO1xuICAgIHRoaXMuX291dGRpciA9IHByb3BzLm91dGRpcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIHRoZSBnaXZlbiBvcHRpb25hbCBvdXRwdXQgZGlyZWN0b3J5IGludG8gYSBmaXhlZCBvdXRwdXQgZGlyZWN0b3J5XG4gICAqL1xuICBwdWJsaWMgZ2V0IG91dGRpcigpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fb3V0ZGlyKSB7XG4gICAgICBjb25zdCBvdXRkaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oZnMucmVhbHBhdGhTeW5jKG9zLnRtcGRpcigpKSwgJ2Nkay5vdXQnKSk7XG4gICAgICB0aGlzLl9vdXRkaXIgPSBvdXRkaXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vdXRkaXI7XG4gIH1cblxuICAvKipcbiAgICogR3Vlc3MgdGhlIGV4ZWN1dGFibGUgZnJvbSB0aGUgY29tbWFuZC1saW5lIGFyZ3VtZW50XG4gICAqXG4gICAqIE9ubHkgZG8gdGhpcyBpZiB0aGUgZmlsZSBpcyBOT1QgbWFya2VkIGFzIGV4ZWN1dGFibGUuIElmIGl0IGlzLFxuICAgKiB3ZSdsbCBkZWZlciB0byB0aGUgc2hlYmFuZyBpbnNpZGUgdGhlIGZpbGUgaXRzZWxmLlxuICAgKlxuICAgKiBJZiB3ZSdyZSBvbiBXaW5kb3dzLCB3ZSBBTFdBWVMgdGFrZSB0aGUgaGFuZGxlciwgc2luY2UgaXQncyBoYXJkIHRvXG4gICAqIHZlcmlmeSBpZiByZWdpc3RyeSBhc3NvY2lhdGlvbnMgaGF2ZSBvciBoYXZlIG5vdCBiZWVuIHNldCB1cCBmb3IgdGhpc1xuICAgKiBmaWxlIHR5cGUsIHNvIHdlJ2xsIGFzc3VtZSB0aGUgd29yc3QgYW5kIHRha2UgY29udHJvbC5cbiAgICovXG4gIHB1YmxpYyBndWVzc0V4ZWN1dGFibGUoYXBwOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZ3Vlc3NFeGVjdXRhYmxlKGFwcCwgdGhpcy5kZWJ1Z0ZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBkb24ndCBoYXZlIHJlZ2lvbi9hY2NvdW50IGRlZmluZWQgaW4gY29udGV4dCwgd2UgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IFNESyBiZWhhdmlvclxuICAgKiB3aGVyZSByZWdpb24gaXMgcmV0cmlldmVkIGZyb20gfi8uYXdzL2NvbmZpZyBhbmQgYWNjb3VudCBpcyBiYXNlZCBvbiBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyXG4gICAqIGNoYWluIGFuZCB0aGVuIFNUUyBpcyBxdWVyaWVkLlxuICAgKlxuICAgKiBUaGlzIGlzIGRvbmUgb3Bwb3J0dW5pc3RpY2FsbHk6IGZvciBleGFtcGxlLCBpZiB3ZSBjYW4ndCBhY2Nlc3MgU1RTIGZvciBzb21lIHJlYXNvbiBvciB0aGUgcmVnaW9uXG4gICAqIGlzIG5vdCBjb25maWd1cmVkLCB0aGUgY29udGV4dCB2YWx1ZSB3aWxsIGJlICdudWxsJyBhbmQgdGhlcmUgY291bGQgZmFpbHVyZXMgZG93biB0aGUgbGluZS4gSW5cbiAgICogc29tZSBjYXNlcywgc3ludGhlc2lzIGRvZXMgbm90IHJlcXVpcmUgcmVnaW9uL2FjY291bnQgaW5mb3JtYXRpb24gYXQgYWxsLCBzbyB0aGF0IG1pZ2h0IGJlIHBlcmZlY3RseVxuICAgKiBmaW5lIGluIGNlcnRhaW4gc2NlbmFyaW9zLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlZmF1bHRFbnZWYXJzKCk6IFByb21pc2U8RW52PiB7XG4gICAgY29uc3QgZGVidWdGbiA9IChtc2c6IHN0cmluZykgPT4gdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0kwMDEwLm1zZyhtc2cpKTtcbiAgICBjb25zdCBlbnYgPSBhd2FpdCBvbGRQcmVwYXJlKHRoaXMuc2RrUHJvdmlkZXIsIGRlYnVnRm4pO1xuXG4gICAgZW52W2N4YXBpLk9VVERJUl9FTlZdID0gdGhpcy5vdXRkaXI7XG4gICAgYXdhaXQgZGVidWdGbihmb3JtYXQoJ291dGRpcjonLCB0aGlzLm91dGRpcikpO1xuXG4gICAgLy8gQ0xJIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgICBlbnZbY3hhcGkuQ0xJX0FTTV9WRVJTSU9OX0VOVl0gPSBjeHNjaGVtYS5NYW5pZmVzdC52ZXJzaW9uKCk7XG4gICAgZW52W2N4YXBpLkNMSV9WRVJTSU9OX0VOVl0gPSB2ZXJzaW9uTnVtYmVyKCk7XG5cbiAgICBhd2FpdCBkZWJ1Z0ZuKGZvcm1hdCgnZW52OicsIGVudikpO1xuICAgIHJldHVybiBlbnY7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGNvZGUgZnJvbSBhIGRpZmZlcmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNoYW5nZURpcjxUPihibG9jazogKCkgPT4gUHJvbWlzZTxUPiwgd29ya2luZ0Rpcj86IHN0cmluZykge1xuICAgIGNvbnN0IG9yaWdpbmFsV29ya2luZ0RpciA9IHByb2Nlc3MuY3dkKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh3b3JraW5nRGlyKSB7XG4gICAgICAgIHByb2Nlc3MuY2hkaXIod29ya2luZ0Rpcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCBibG9jaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAod29ya2luZ0Rpcikge1xuICAgICAgICBwcm9jZXNzLmNoZGlyKG9yaWdpbmFsV29ya2luZ0Rpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBjb2RlIHdpdGggYWRkaXRpb25hbCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB3aXRoRW52PFQ+KGVudjogRW52ID0ge30sIGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcbiAgICB0cnkge1xuICAgICAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgICAgIC4uLm9yaWdpbmFsRW52LFxuICAgICAgICAuLi5lbnYsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVuIGNvZGUgd2l0aCBjb250ZXh0IHNldHVwIGluc2lkZSB0aGUgZW52aXJvbm1lbnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyB3aXRoQ29udGV4dDxUPihcbiAgICBpbnB1dENvbnRleHQ6IENvbnRleHQsXG4gICAgZW52OiBFbnYsXG4gICAgc3ludGhPcHRzOiBBcHBTeW50aE9wdGlvbnMgPSB7fSxcbiAgICBibG9jazogKGVudjogRW52LCBjb250ZXh0OiBDb250ZXh0KSA9PiBQcm9taXNlPFQ+LFxuICApIHtcbiAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgcHJlcGFyZUNvbnRleHQoc3ludGhPcHRzRGVmYXVsdHMoc3ludGhPcHRzKSwgaW5wdXRDb250ZXh0LCBlbnYsIHRoaXMuZGVidWdGbik7XG4gICAgbGV0IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnZWYXJpYWJsZVNpemVMaW1pdCA9IG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicgPyAzMjc2MCA6IDEzMTA3MjtcbiAgICAgIGNvbnN0IFtzbWFsbENvbnRleHQsIG92ZXJmbG93XSA9IHNwbGl0QnlTaXplKGNvbnRleHQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dChlbnYsIGVudlZhcmlhYmxlU2l6ZUxpbWl0KSk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBzYWZlIHBhcnQgaW4gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICBlbnZbY3hhcGkuQ09OVEVYVF9FTlZdID0gSlNPTi5zdHJpbmdpZnkoc21hbGxDb250ZXh0KTtcblxuICAgICAgLy8gSWYgdGhlcmUgd2FzIGFueSBvdmVyZmxvdywgd3JpdGUgaXQgdG8gYSB0ZW1wb3JhcnkgZmlsZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKG92ZXJmbG93ID8/IHt9KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHREaXIgPSBmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4ob3MudG1wZGlyKCksICdjZGstY29udGV4dCcpKTtcbiAgICAgICAgY29udGV4dE92ZXJmbG93TG9jYXRpb24gPSBwYXRoLmpvaW4oY29udGV4dERpciwgJ2NvbnRleHQtb3ZlcmZsb3cuanNvbicpO1xuICAgICAgICBmcy53cml0ZUpTT05TeW5jKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uLCBvdmVyZmxvdyk7XG4gICAgICAgIGVudltjeGFwaS5DT05URVhUX09WRVJGTE9XX0xPQ0FUSU9OX0VOVl0gPSBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCB0aGUgYmxvY2sgY29kZSB3aXRoIG5ldyBlbnZpcm9ubWVudFxuICAgICAgcmV0dXJuIGF3YWl0IGJsb2NrKGVudiwgY29udGV4dCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbikge1xuICAgICAgICBmcy5yZW1vdmVTeW5jKHBhdGguZGlybmFtZShjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFzc2VtYmx5IHN1cHBvcnRzIGNvbnRleHQgb3ZlcmZsb3csIHdhcm4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBhc3NlbWJseSB0aGUgYXNzZW1ibHkgdG8gY2hlY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tDb250ZXh0T3ZlcmZsb3dTdXBwb3J0KGFzc2VtYmx5OiBjeGFwaS5DbG91ZEFzc2VtYmx5LCBpb0hlbHBlcjogSW9IZWxwZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgdHJhY2VGbiA9IChtc2c6IHN0cmluZykgPT4gaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfQVNTRU1CTFlfVFJBQ0UubXNnKG1zZykpO1xuICBjb25zdCB0cmVlID0gYXdhaXQgbG9hZFRyZWUoYXNzZW1ibHksIHRyYWNlRm4pO1xuICBjb25zdCBmcmFtZXdvcmtEb2VzTm90U3VwcG9ydENvbnRleHRPdmVyZmxvdyA9IHNvbWUodHJlZSwgbm9kZSA9PiB7XG4gICAgY29uc3QgZnFuID0gbm9kZS5jb25zdHJ1Y3RJbmZvPy5mcW47XG4gICAgY29uc3QgdmVyc2lvbiA9IG5vZGUuY29uc3RydWN0SW5mbz8udmVyc2lvbjtcbiAgICByZXR1cm4gKGZxbiA9PT0gJ2F3cy1jZGstbGliLkFwcCcgJiYgdmVyc2lvbiAhPSBudWxsICYmIGx0ZSh2ZXJzaW9uLCAnMi4zOC4wJykpIC8vIHYyXG4gICAgfHwgZnFuID09PSAnQGF3cy1jZGsvY29yZS5BcHAnOyAvLyB2MVxuICB9KTtcblxuICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggYW4gb2xkIHZlcnNpb24gb2YgdGhlIGZyYW1ld29yayBoZXJlLiBJdCBpcyB1bmF3YXJlIG9mIHRoZSB0ZW1wb3JhcnlcbiAgLy8gZmlsZSwgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIGlnbm9yZSB0aGUgY29udGV4dCBvdmVyZmxvdy5cbiAgaWYgKGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93KSB7XG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19BU1NFTUJMWV9XMDAxMC5tc2coJ1BhcnQgb2YgdGhlIGNvbnRleHQgY291bGQgbm90IGJlIHNlbnQgdG8gdGhlIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBkYXRlIHRoZSBBV1MgQ0RLIGxpYnJhcnkgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLicpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhZmVseSBjcmVhdGUgYW4gYXNzZW1ibHkgZnJvbSBhIGNsb3VkIGFzc2VtYmx5IGRpcmVjdG9yeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzZW1ibHlGcm9tRGlyZWN0b3J5KGFzc2VtYmx5RGlyOiBzdHJpbmcsIGlvSGVscGVyOiBJb0hlbHBlciwgbG9hZE9wdGlvbnM6IExvYWRBc3NlbWJseU9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkoYXNzZW1ibHlEaXIsIHtcbiAgICAgIHNraXBWZXJzaW9uQ2hlY2s6ICEobG9hZE9wdGlvbnMuY2hlY2tWZXJzaW9uID8/IHRydWUpLFxuICAgICAgc2tpcEVudW1DaGVjazogIShsb2FkT3B0aW9ucy5jaGVja0VudW1zID8/IHRydWUpLFxuICAgICAgLy8gV2Ugc29ydCBhcyB3ZSBkZXBsb3lcbiAgICAgIHRvcG9Tb3J0OiBmYWxzZSxcbiAgICB9KTtcbiAgICBhd2FpdCBjaGVja0NvbnRleHRPdmVyZmxvd1N1cHBvcnQoYXNzZW1ibHksIGlvSGVscGVyKTtcbiAgICByZXR1cm4gYXNzZW1ibHk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKGN4c2NoZW1hLlZFUlNJT05fTUlTTUFUQ0gpKSB7XG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSBDTEkgdmVyc2lvbiBpcyB0b28gb2xkLlxuICAgICAgLy8gd2UgaW5zdHJ1Y3QgdGhlIHVzZXIgdG8gdXBncmFkZS5cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnVGhpcyBBV1MgQ0RLIFRvb2xraXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQVdTIENESyBsaWJyYXJ5IHVzZWQgYnkgeW91ciBhcHBsaWNhdGlvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLic7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX0UxMTExLm1zZyhtZXNzYWdlLCB7IGVycm9yOiBlcnIgfSkpO1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttZXNzYWdlfVxcbigke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3ludGhPcHRzRGVmYXVsdHMoc3ludGhPcHRzOiBBcHBTeW50aE9wdGlvbnMgPSB7fSk6IFNldHRpbmdzIHtcbiAgcmV0dXJuIG5ldyBTZXR0aW5ncyh7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIHBhdGhNZXRhZGF0YTogdHJ1ZSxcbiAgICB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlLFxuICAgIGFzc2V0TWV0YWRhdGE6IHRydWUsXG4gICAgYXNzZXRTdGFnaW5nOiB0cnVlLFxuICAgIC4uLnN5bnRoT3B0cyxcbiAgfSwgdHJ1ZSk7XG59XG4iXX0=