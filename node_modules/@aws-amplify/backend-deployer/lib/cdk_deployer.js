import process from 'node:process';
import { AmplifyError, AmplifyFault, CDKContextKey, } from '@aws-amplify/platform-core';
import path from 'path';
import { HotswapMode, StackSelectionStrategy, } from '@aws-cdk/toolkit-lib';
import { tsImport } from 'tsx/esm/api';
import { CloudAssembly } from 'aws-cdk-lib/cx-api';
import { pathToFileURL } from 'url';
import { AssetStaging } from 'aws-cdk-lib/core';
import { Worker } from 'node:worker_threads';
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    cdkToolkit;
    ioHost;
    absoluteCloudAssemblyLocation = path.resolve(process.cwd(), '.amplify/artifacts/cdk.out');
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController, cdkToolkit, ioHost) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
        this.cdkToolkit = cdkToolkit;
        this.ioHost = ioHost;
    }
    /**
     * Invokes cdk deploy API
     */
    deploy = async (backendId, deployProps) => {
        // Hack?? CDK uses global asset cache that is not cleared if assets are
        // changing within the same process (which now happens with CDK Toolkit APIs)
        // See https://github.com/aws/aws-cdk-cli/issues/236
        AssetStaging.clearAssetHashCache();
        const cx = await this.getCdkCloudAssembly(backendId, deployProps?.secretLastUpdated?.getTime());
        // Initiate synth for the cloud executable and send a message for display.
        const synthStartTime = Date.now();
        let synthAssembly, synthError = undefined;
        await this.ioHost.notify({
            message: `Backend synthesis started`,
            code: 'SYNTH_STARTED',
            action: 'amplify',
            time: new Date(),
            level: 'info',
            data: undefined,
        });
        try {
            synthAssembly = await this.cdkToolkit.synth(cx, {
                stacks: {
                    strategy: StackSelectionStrategy.ALL_STACKS,
                },
            });
        }
        catch (error) {
            synthError = error;
        }
        const synthTimeSeconds = Math.floor((Date.now() - synthStartTime) / 10) / 100;
        await this.ioHost.notify({
            message: `Backend synthesized in ${synthTimeSeconds} seconds`,
            code: 'SYNTH_FINISHED',
            action: 'amplify',
            time: new Date(),
            level: 'result',
            data: undefined,
        });
        // Typescript compilation. For type related errors, we prefer to show errors from TS to customers rather than synth
        const typeCheckStartTime = Date.now();
        await this.ioHost.notify({
            message: `Backend type checks started`,
            code: 'TS_STARTED',
            action: 'amplify',
            time: new Date(),
            level: 'info',
            data: undefined,
        });
        if (deployProps?.validateAppSources) {
            try {
                await this.compileProject(path.dirname(this.backendLocator.locate()));
            }
            catch (typeError) {
                if (synthError &&
                    AmplifyError.isAmplifyError(typeError) &&
                    typeError.name === 'FunctionEnvVarFileNotGeneratedError') {
                    // synth has failed and we don't have auto generated function environment definition files. This
                    // resulted in the exception caught here, which is not very useful for the customers.
                    // We instead throw the synth error for customers to fix what caused the synth to fail.
                    throw this.cdkErrorMapper.getAmplifyError(synthError, backendId.type);
                }
                throw typeError;
            }
            finally {
                const typeCheckTimeSeconds = Math.floor((Date.now() - typeCheckStartTime) / 10) / 100;
                await this.ioHost.notify({
                    message: `Type checks completed in ${typeCheckTimeSeconds} seconds`,
                    code: 'TS_FINISHED',
                    action: 'amplify',
                    time: new Date(),
                    level: 'result',
                    data: undefined,
                });
            }
        }
        // If typescript compilation was successful but synth had failed, we throw synth error
        if (synthError) {
            throw this.cdkErrorMapper.getAmplifyError(synthError, backendId.type);
        }
        // Perform actual deployment. CFN or hotswap
        const deployStartTime = Date.now();
        try {
            await this.cdkToolkit.deploy(synthAssembly, {
                stacks: {
                    strategy: StackSelectionStrategy.ALL_STACKS,
                },
                hotswap: backendId.type === 'sandbox'
                    ? HotswapMode.FALL_BACK
                    : HotswapMode.FULL_DEPLOYMENT,
            });
        }
        catch (error) {
            throw this.cdkErrorMapper.getAmplifyError(error, backendId.type);
        }
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds +
                    Math.floor((Date.now() - deployStartTime) / 10) / 100,
            },
        };
    };
    /**
     * Invokes cdk destroy API
     */
    destroy = async (backendId) => {
        const deploymentStartTime = Date.now();
        await this.cdkToolkit.destroy(await this.getCdkCloudAssembly(backendId), {
            stacks: {
                strategy: StackSelectionStrategy.ALL_STACKS,
            },
        });
        return {
            deploymentTimes: {
                totalTime: Math.floor((Date.now() - deploymentStartTime) / 10) / 100,
            },
        };
    };
    compileProject = (projectDirectory) => {
        return new Promise((resolve, reject) => {
            const worker = new Worker(new URL('ts_compiler.js', import.meta.url), {
                workerData: { projectDirectory },
            });
            worker.on('message', () => {
                // do nothing
            });
            worker.on('error', reject);
            worker.on('exit', (code) => {
                if (code !== 0) {
                    reject(new AmplifyFault('TSCompilerWorkerFault', {
                        message: `Worker stopped with exit code ${code}`,
                    }));
                }
                resolve();
            });
        });
    };
    /**
     * Build cloud executable from dynamically importing the cdk ts file, i.e. backend.ts
     */
    getCdkCloudAssembly = (backendId, secretLastUpdated) => {
        const contextParams = {};
        if (backendId.type === 'sandbox') {
            if (secretLastUpdated) {
                contextParams['secretLastUpdated'] = secretLastUpdated;
            }
        }
        contextParams[CDKContextKey.BACKEND_NAMESPACE] = backendId.namespace;
        contextParams[CDKContextKey.BACKEND_NAME] = backendId.name;
        contextParams[CDKContextKey.DEPLOYMENT_TYPE] = backendId.type;
        return this.cdkToolkit.fromAssemblyBuilder(async () => {
            await tsImport(pathToFileURL(this.backendLocator.locate()).toString(), import.meta.url);
            /**
              By not having a child process with toolkit lib, the `process.on('beforeExit')` does not execute
              on the CDK side resulting in the app not getting synthesized properly. So we send a signal/message
              to the same process and catch it in backend package where App is initialized to explicitly perform synth
             */
            process.emit('message', 'amplifySynth', undefined);
            return new CloudAssembly(this.absoluteCloudAssemblyLocation);
        }, { context: contextParams, outdir: this.absoluteCloudAssemblyLocation });
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFZbkMsT0FBTyxFQUNMLFlBQVksRUFDWixZQUFZLEVBRVosYUFBYSxHQUNkLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFDTCxXQUFXLEVBQ1gsc0JBQXNCLEdBRXZCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN2QyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUNwQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRTdDOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFVSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBYkYsNkJBQTZCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FDM0QsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUNiLDRCQUE0QixDQUM3QixDQUFDO0lBRUY7O09BRUc7SUFDSCxZQUNtQixjQUE4QixFQUM5QixjQUE4QixFQUM5Qix3QkFBa0QsRUFDbEQsVUFBbUIsRUFDbkIsTUFBcUI7UUFKckIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5Qiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBQ2xELGVBQVUsR0FBVixVQUFVLENBQVM7UUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBZTtJQUNyQyxDQUFDO0lBRUo7O09BRUc7SUFDSCxNQUFNLEdBQUcsS0FB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QztZQUNGOzs7O2VBSUc7WUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkQsT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUMvRCxDQUFDLEVBQ0QsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsNkJBQTZCLEVBQUUsQ0FDdkUsQ0FBQztJQUNKLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcblxuaW1wb3J0IHtcbiAgQmFja2VuZERlcGxveWVyLFxuICBEZXBsb3lQcm9wcyxcbn0gZnJvbSAnLi9jZGtfZGVwbG95ZXJfc2luZ2xldG9uX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgQ2RrRXJyb3JNYXBwZXIgfSBmcm9tICcuL2Nka19lcnJvcl9tYXBwZXIuanMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeUlPSG9zdCxcbiAgQmFja2VuZElkZW50aWZpZXIsXG4gIHR5cGUgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeUZhdWx0LFxuICBCYWNrZW5kTG9jYXRvcixcbiAgQ0RLQ29udGV4dEtleSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge1xuICBIb3Rzd2FwTW9kZSxcbiAgU3RhY2tTZWxlY3Rpb25TdHJhdGVneSxcbiAgVG9vbGtpdCxcbn0gZnJvbSAnQGF3cy1jZGsvdG9vbGtpdC1saWInO1xuaW1wb3J0IHsgdHNJbXBvcnQgfSBmcm9tICd0c3gvZXNtL2FwaSc7XG5pbXBvcnQgeyBDbG91ZEFzc2VtYmx5IH0gZnJvbSAnYXdzLWNkay1saWIvY3gtYXBpJztcbmltcG9ydCB7IHBhdGhUb0ZpbGVVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgQXNzZXRTdGFnaW5nIH0gZnJvbSAnYXdzLWNkay1saWIvY29yZSc7XG5pbXBvcnQgeyBXb3JrZXIgfSBmcm9tICdub2RlOndvcmtlcl90aHJlYWRzJztcblxuLyoqXG4gKiBJbnZva2VzIENESyBjb21tYW5kIHZpYSBleGVjYVxuICovXG5leHBvcnQgY2xhc3MgQ0RLRGVwbG95ZXIgaW1wbGVtZW50cyBCYWNrZW5kRGVwbG95ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGFic29sdXRlQ2xvdWRBc3NlbWJseUxvY2F0aW9uID0gcGF0aC5yZXNvbHZlKFxuICAgIHByb2Nlc3MuY3dkKCksXG4gICAgJy5hbXBsaWZ5L2FydGlmYWN0cy9jZGsub3V0JyxcbiAgKTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGluc3RhbmNlIG9mIENES0RlcGxveWVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNka0Vycm9yTWFwcGVyOiBDZGtFcnJvck1hcHBlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRMb2NhdG9yOiBCYWNrZW5kTG9jYXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcjogUGFja2FnZU1hbmFnZXJDb250cm9sbGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RrVG9vbGtpdDogVG9vbGtpdCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlvSG9zdDogQW1wbGlmeUlPSG9zdCxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXBsb3kgQVBJXG4gICAqL1xuICBkZXBsb3kgPSBhc3luYyAoYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllciwgZGVwbG95UHJvcHM/OiBEZXBsb3lQcm9wcykgPT4ge1xuICAgIC8vIEhhY2s/PyBDREsgdXNlcyBnbG9iYWwgYXNzZXQgY2FjaGUgdGhhdCBpcyBub3QgY2xlYXJlZCBpZiBhc3NldHMgYXJlXG4gICAgLy8gY2hhbmdpbmcgd2l0aGluIHRoZSBzYW1lIHByb2Nlc3MgKHdoaWNoIG5vdyBoYXBwZW5zIHdpdGggQ0RLIFRvb2xraXQgQVBJcylcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrLWNsaS9pc3N1ZXMvMjM2XG4gICAgQXNzZXRTdGFnaW5nLmNsZWFyQXNzZXRIYXNoQ2FjaGUoKTtcblxuICAgIGNvbnN0IGN4ID0gYXdhaXQgdGhpcy5nZXRDZGtDbG91ZEFzc2VtYmx5KFxuICAgICAgYmFja2VuZElkLFxuICAgICAgZGVwbG95UHJvcHM/LnNlY3JldExhc3RVcGRhdGVkPy5nZXRUaW1lKCksXG4gICAgKTtcbiAgICAvLyBJbml0aWF0ZSBzeW50aCBmb3IgdGhlIGNsb3VkIGV4ZWN1dGFibGUgYW5kIHNlbmQgYSBtZXNzYWdlIGZvciBkaXNwbGF5LlxuICAgIGNvbnN0IHN5bnRoU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3ludGhBc3NlbWJseSxcbiAgICAgIHN5bnRoRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGF3YWl0IHRoaXMuaW9Ib3N0Lm5vdGlmeSh7XG4gICAgICBtZXNzYWdlOiBgQmFja2VuZCBzeW50aGVzaXMgc3RhcnRlZGAsXG4gICAgICBjb2RlOiAnU1lOVEhfU1RBUlRFRCcsXG4gICAgICBhY3Rpb246ICdhbXBsaWZ5JyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgICBsZXZlbDogJ2luZm8nLFxuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN5bnRoQXNzZW1ibHkgPSBhd2FpdCB0aGlzLmNka1Rvb2xraXQuc3ludGgoY3gsIHtcbiAgICAgICAgc3RhY2tzOiB7XG4gICAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuQUxMX1NUQUNLUyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzeW50aEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ludGhUaW1lU2Vjb25kcyA9XG4gICAgICBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gc3ludGhTdGFydFRpbWUpIC8gMTApIC8gMTAwO1xuXG4gICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHtcbiAgICAgIG1lc3NhZ2U6IGBCYWNrZW5kIHN5bnRoZXNpemVkIGluICR7c3ludGhUaW1lU2Vjb25kc30gc2Vjb25kc2AsXG4gICAgICBjb2RlOiAnU1lOVEhfRklOSVNIRUQnLFxuICAgICAgYWN0aW9uOiAnYW1wbGlmeScsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgbGV2ZWw6ICdyZXN1bHQnLFxuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgLy8gVHlwZXNjcmlwdCBjb21waWxhdGlvbi4gRm9yIHR5cGUgcmVsYXRlZCBlcnJvcnMsIHdlIHByZWZlciB0byBzaG93IGVycm9ycyBmcm9tIFRTIHRvIGN1c3RvbWVycyByYXRoZXIgdGhhbiBzeW50aFxuICAgIGNvbnN0IHR5cGVDaGVja1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHtcbiAgICAgIG1lc3NhZ2U6IGBCYWNrZW5kIHR5cGUgY2hlY2tzIHN0YXJ0ZWRgLFxuICAgICAgY29kZTogJ1RTX1NUQVJURUQnLFxuICAgICAgYWN0aW9uOiAnYW1wbGlmeScsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIGlmIChkZXBsb3lQcm9wcz8udmFsaWRhdGVBcHBTb3VyY2VzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbXBpbGVQcm9qZWN0KHBhdGguZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSk7XG4gICAgICB9IGNhdGNoICh0eXBlRXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN5bnRoRXJyb3IgJiZcbiAgICAgICAgICBBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IodHlwZUVycm9yKSAmJlxuICAgICAgICAgIHR5cGVFcnJvci5uYW1lID09PSAnRnVuY3Rpb25FbnZWYXJGaWxlTm90R2VuZXJhdGVkRXJyb3InXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHN5bnRoIGhhcyBmYWlsZWQgYW5kIHdlIGRvbid0IGhhdmUgYXV0byBnZW5lcmF0ZWQgZnVuY3Rpb24gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBmaWxlcy4gVGhpc1xuICAgICAgICAgIC8vIHJlc3VsdGVkIGluIHRoZSBleGNlcHRpb24gY2F1Z2h0IGhlcmUsIHdoaWNoIGlzIG5vdCB2ZXJ5IHVzZWZ1bCBmb3IgdGhlIGN1c3RvbWVycy5cbiAgICAgICAgICAvLyBXZSBpbnN0ZWFkIHRocm93IHRoZSBzeW50aCBlcnJvciBmb3IgY3VzdG9tZXJzIHRvIGZpeCB3aGF0IGNhdXNlZCB0aGUgc3ludGggdG8gZmFpbC5cbiAgICAgICAgICB0aHJvdyB0aGlzLmNka0Vycm9yTWFwcGVyLmdldEFtcGxpZnlFcnJvcihzeW50aEVycm9yLCBiYWNrZW5kSWQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdHlwZUVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgdHlwZUNoZWNrVGltZVNlY29uZHMgPVxuICAgICAgICAgIE1hdGguZmxvb3IoKERhdGUubm93KCkgLSB0eXBlQ2hlY2tTdGFydFRpbWUpIC8gMTApIC8gMTAwO1xuICAgICAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBUeXBlIGNoZWNrcyBjb21wbGV0ZWQgaW4gJHt0eXBlQ2hlY2tUaW1lU2Vjb25kc30gc2Vjb25kc2AsXG4gICAgICAgICAgY29kZTogJ1RTX0ZJTklTSEVEJyxcbiAgICAgICAgICBhY3Rpb246ICdhbXBsaWZ5JyxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGxldmVsOiAncmVzdWx0JyxcbiAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHR5cGVzY3JpcHQgY29tcGlsYXRpb24gd2FzIHN1Y2Nlc3NmdWwgYnV0IHN5bnRoIGhhZCBmYWlsZWQsIHdlIHRocm93IHN5bnRoIGVycm9yXG4gICAgaWYgKHN5bnRoRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuY2RrRXJyb3JNYXBwZXIuZ2V0QW1wbGlmeUVycm9yKHN5bnRoRXJyb3IsIGJhY2tlbmRJZC50eXBlKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGFjdHVhbCBkZXBsb3ltZW50LiBDRk4gb3IgaG90c3dhcFxuICAgIGNvbnN0IGRlcGxveVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2RrVG9vbGtpdC5kZXBsb3koc3ludGhBc3NlbWJseSEsIHtcbiAgICAgICAgc3RhY2tzOiB7XG4gICAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuQUxMX1NUQUNLUyxcbiAgICAgICAgfSxcbiAgICAgICAgaG90c3dhcDpcbiAgICAgICAgICBiYWNrZW5kSWQudHlwZSA9PT0gJ3NhbmRib3gnXG4gICAgICAgICAgICA/IEhvdHN3YXBNb2RlLkZBTExfQkFDS1xuICAgICAgICAgICAgOiBIb3Rzd2FwTW9kZS5GVUxMX0RFUExPWU1FTlQsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5jZGtFcnJvck1hcHBlci5nZXRBbXBsaWZ5RXJyb3IoZXJyb3IgYXMgRXJyb3IsIGJhY2tlbmRJZC50eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGVwbG95bWVudFRpbWVzOiB7XG4gICAgICAgIHN5bnRoZXNpc1RpbWU6IHN5bnRoVGltZVNlY29uZHMsXG4gICAgICAgIHRvdGFsVGltZTpcbiAgICAgICAgICBzeW50aFRpbWVTZWNvbmRzICtcbiAgICAgICAgICBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gZGVwbG95U3RhcnRUaW1lKSAvIDEwKSAvIDEwMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVzdHJveSBBUElcbiAgICovXG4gIGRlc3Ryb3kgPSBhc3luYyAoYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcikgPT4ge1xuICAgIGNvbnN0IGRlcGxveW1lbnRTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHRoaXMuY2RrVG9vbGtpdC5kZXN0cm95KGF3YWl0IHRoaXMuZ2V0Q2RrQ2xvdWRBc3NlbWJseShiYWNrZW5kSWQpLCB7XG4gICAgICBzdGFja3M6IHtcbiAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuQUxMX1NUQUNLUyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcGxveW1lbnRUaW1lczoge1xuICAgICAgICB0b3RhbFRpbWU6IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBkZXBsb3ltZW50U3RhcnRUaW1lKSAvIDEwKSAvIDEwMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBjb21waWxlUHJvamVjdCA9IChwcm9qZWN0RGlyZWN0b3J5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCd0c19jb21waWxlci5qcycsIGltcG9ydC5tZXRhLnVybCksIHtcbiAgICAgICAgd29ya2VyRGF0YTogeyBwcm9qZWN0RGlyZWN0b3J5IH0sXG4gICAgICB9KTtcbiAgICAgIHdvcmtlci5vbignbWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIHdvcmtlci5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEFtcGxpZnlGYXVsdCgnVFNDb21waWxlcldvcmtlckZhdWx0Jywge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgV29ya2VyIHN0b3BwZWQgd2l0aCBleGl0IGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZCBjbG91ZCBleGVjdXRhYmxlIGZyb20gZHluYW1pY2FsbHkgaW1wb3J0aW5nIHRoZSBjZGsgdHMgZmlsZSwgaS5lLiBiYWNrZW5kLnRzXG4gICAqL1xuICBwcml2YXRlIGdldENka0Nsb3VkQXNzZW1ibHkgPSAoXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBzZWNyZXRMYXN0VXBkYXRlZD86IG51bWJlcixcbiAgKSA9PiB7XG4gICAgY29uc3QgY29udGV4dFBhcmFtczoge1xuICAgICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgICB9ID0ge307XG5cbiAgICBpZiAoYmFja2VuZElkLnR5cGUgPT09ICdzYW5kYm94Jykge1xuICAgICAgaWYgKHNlY3JldExhc3RVcGRhdGVkKSB7XG4gICAgICAgIGNvbnRleHRQYXJhbXNbJ3NlY3JldExhc3RVcGRhdGVkJ10gPSBzZWNyZXRMYXN0VXBkYXRlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0UGFyYW1zW0NES0NvbnRleHRLZXkuQkFDS0VORF9OQU1FU1BBQ0VdID0gYmFja2VuZElkLm5hbWVzcGFjZTtcbiAgICBjb250ZXh0UGFyYW1zW0NES0NvbnRleHRLZXkuQkFDS0VORF9OQU1FXSA9IGJhY2tlbmRJZC5uYW1lO1xuICAgIGNvbnRleHRQYXJhbXNbQ0RLQ29udGV4dEtleS5ERVBMT1lNRU5UX1RZUEVdID0gYmFja2VuZElkLnR5cGU7XG4gICAgcmV0dXJuIHRoaXMuY2RrVG9vbGtpdC5mcm9tQXNzZW1ibHlCdWlsZGVyKFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0c0ltcG9ydChcbiAgICAgICAgICBwYXRoVG9GaWxlVVJMKHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCkpLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW1wb3J0Lm1ldGEudXJsLFxuICAgICAgICApO1xuICAgICAgICAvKipcbiAgICAgICAgICBCeSBub3QgaGF2aW5nIGEgY2hpbGQgcHJvY2VzcyB3aXRoIHRvb2xraXQgbGliLCB0aGUgYHByb2Nlc3Mub24oJ2JlZm9yZUV4aXQnKWAgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgICAgIG9uIHRoZSBDREsgc2lkZSByZXN1bHRpbmcgaW4gdGhlIGFwcCBub3QgZ2V0dGluZyBzeW50aGVzaXplZCBwcm9wZXJseS4gU28gd2Ugc2VuZCBhIHNpZ25hbC9tZXNzYWdlXG4gICAgICAgICAgdG8gdGhlIHNhbWUgcHJvY2VzcyBhbmQgY2F0Y2ggaXQgaW4gYmFja2VuZCBwYWNrYWdlIHdoZXJlIEFwcCBpcyBpbml0aWFsaXplZCB0byBleHBsaWNpdGx5IHBlcmZvcm0gc3ludGhcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3MuZW1pdCgnbWVzc2FnZScsICdhbXBsaWZ5U3ludGgnLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gbmV3IENsb3VkQXNzZW1ibHkodGhpcy5hYnNvbHV0ZUNsb3VkQXNzZW1ibHlMb2NhdGlvbik7XG4gICAgICB9LFxuICAgICAgeyBjb250ZXh0OiBjb250ZXh0UGFyYW1zLCBvdXRkaXI6IHRoaXMuYWJzb2x1dGVDbG91ZEFzc2VtYmx5TG9jYXRpb24gfSxcbiAgICApO1xuICB9O1xufVxuIl19