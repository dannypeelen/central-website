import debounce from 'debounce-promise';
import { subscribe as _subscribe } from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { GetParameterCommand, ParameterNotFound, SSMServiceException, } from '@aws-sdk/client-ssm';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, } from '@aws-amplify/platform-core';
import { EOL } from 'os';
/**
 * CDK stores bootstrap version in parameter store. Example parameter name looks like /cdk-bootstrap/<qualifier>/version.
 * The default value for qualifier is hnb659fds, i.e. default parameter path is /cdk-bootstrap/hnb659fds/version.
 * The default qualifier is hardcoded value without any significance.
 * Ability to provide custom qualifier is intended for name isolation between automated tests of the CDK itself.
 * In order to use custom qualifier all stack synthesizers must be programmatically configured to use it.
 * That makes bootstraps with custom qualifier incompatible with Amplify Backend and we treat that setup as
 * not bootstrapped.
 * See: https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html
 */
export const CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME = 
// suppress spell checker, it is triggered by qualifier value.
// eslint-disable-next-line spellcheck/spell-checker
'/cdk-bootstrap/hnb659fds/version';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    ssmClient;
    functionsLogStreamer;
    printer;
    open;
    subscribe;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, ssmClient, functionsLogStreamer, printer, open = _open, subscribe = _subscribe) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.ssmClient = ssmClient;
        this.functionsLogStreamer = functionsLogStreamer;
        this.printer = printer;
        this.open = open;
        this.subscribe = subscribe;
        this.interceptStderr();
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        // get region from an available sdk client;
        const region = await this.ssmClient.config.region();
        if (!bootstrapped) {
            this.printer.log(`The region ${format.highlight(region)} has not been bootstrapped. Sign in to the AWS console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.${EOL}If this is not the region you are expecting to bootstrap, check for any AWS environment variables that may be set in your shell or use ${format.command('--profile <profile-name>')} to specify a profile with the correct region.`);
            const bootstrapUrl = getBootstrapUrl(region);
            try {
                await this.open(bootstrapUrl);
            }
            catch (e) {
                // If opening the link fails for any reason we fall back to
                // printing the url in the console.
                // This might happen:
                // - in headless environments
                // - if user does not have any app to open URL
                // - if browser crashes
                let logEntry = 'Unable to open bootstrap url';
                if (e instanceof Error) {
                    logEntry = `${logEntry}, ${e.message}`;
                }
                this.printer.log(logEntry, LogLevel.DEBUG);
                this.printer.log(`Open ${bootstrapUrl} in the browser.`);
            }
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        this.printer.clearConsole();
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            // Stop streaming the logs so that deployment logs don't get mixed up
            this.functionsLogStreamer.stopStreamingLogs();
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.clearConsole();
                await this.printSandboxNameInfo(options.identifier);
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            // Idle state, let customers know and start streaming function logs
            this.emitWatching();
            await this.functionsLogStreamer.startStreamingLogs(await this.backendIdSandboxResolver(options.identifier), options.functionStreamingOptions);
        });
        if (watchForChanges) {
            this.watcherSubscription = await this.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(async ({ type: eventName, path: filePath }) => {
                    this.filesChangesTracker.trackFileChange(filePath);
                    if (latch === 'open') {
                        this.printer.clearConsole();
                        await this.printSandboxNameInfo();
                    }
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path.relative(process.cwd(), filePath)}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        this.functionsLogStreamer?.stopStreamingLogs();
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier));
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources);
            this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print a meaningful message
            this.printer.log(format.error(error), LogLevel.ERROR);
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (AmplifyError.isAmplifyError(error) &&
                error.name === 'CFNUpdateNotSupportedError') {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CDK bootstrap version parameter
     * stored in parameter store.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Parameter: parameter } = await this.ssmClient.send(new GetParameterCommand({
                Name: CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME,
            }));
            const bootstrapVersion = parameter?.Value;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e instanceof ParameterNotFound) {
                return false;
            }
            if (e instanceof SSMServiceException &&
                [
                    'UnrecognizedClientException',
                    'AccessDeniedException',
                    'NotAuthorized',
                    'ExpiredTokenException',
                    'ExpiredToken',
                    'InvalidSignatureException',
                ].includes(e.name)) {
                throw new AmplifyUserError('SSMCredentialsError', {
                    message: `${e.name}: ${e.message}`,
                    resolution: 'Make sure your AWS credentials are set up correctly and have permissions to call SSM:GetParameter',
                }, e);
            }
            // If we are unable to retrieve bootstrap version parameter due to other reasons, we fail fast.
            throw e;
        }
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        const region = await this.ssmClient.config.region();
        this.printer.print(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.print(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.print(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        this.printer.print(format.indent(`${format.bold('Region:')} \t${region}`));
        if (!sandboxIdentifier) {
            this.printer.print(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
        this.printer.printNewLine();
    };
    /**
     * Hack to suppress certain stderr messages until aws-cdk constructs
     * can use the toolkit's IoHost to deliver messages.
     * See tracking items https://github.com/aws/aws-cdk-cli/issues/158
     *
     * Rest of the stderr messages are rerouted to our printer so that they
     * don't get intermingled with spinners.
     */
    interceptStderr = () => {
        process.stderr.write = (chunk) => {
            if (typeof chunk !== 'string' ||
                !['Bundling asset'].some((prohibitedStrings) => chunk.includes(prohibitedStrings))) {
                this.printer.log(typeof chunk === 'string' ? chunk : chunk.toLocaleString());
            }
            return true;
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBUzFELE9BQU8sY0FBYyxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxLQUFLLE1BQU0sTUFBTSxDQUFDO0FBQ3pCLCtEQUErRDtBQUMvRCxnRUFBZ0U7QUFDaEUsT0FBTyxZQUFZLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsaUJBQWlCLEVBRWpCLG1CQUFtQixHQUNwQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFDTCxlQUFlLEVBQ2YsUUFBUSxFQUVSLE1BQU0sR0FDUCxNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQ0wsWUFBWSxFQUNaLGdCQUFnQixFQUNoQiw0QkFBNEIsR0FDN0IsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBRXpCOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sQ0FBQyxNQUFNLDRDQUE0QztBQUN2RCw4REFBOEQ7QUFDOUQsb0RBQW9EO0FBQ3BELGtDQUFrQyxDQUFDO0FBQ3JDLE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHLENBQUMsQ0FBQztBQUUzQzs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQUMsTUFBYyxFQUFFLEVBQUUsQ0FDaEQsV0FBVyxN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Q0FBQyxDQUNoRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FDbEMsQ0FBQztRQUNKLENBQUM7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzlCLENBQUMsQ0FBQztJQUVGOzs7Ozs7O09BT0c7SUFDSyxlQUFlLEdBQUcsR0FBRyxFQUFFO1FBQzdCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDL0IsSUFDRSxPQUFPLEtBQUssS0FBSyxRQUFRO2dCQUN6QixDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQzdDLEtBQUssQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FDbEMsRUFDRCxDQUFDO2dCQUNELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQzNELENBQUM7WUFDSixDQUFDO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJvdW5jZSBmcm9tICdkZWJvdW5jZS1wcm9taXNlJztcbmltcG9ydCB7IHN1YnNjcmliZSBhcyBfc3Vic2NyaWJlIH0gZnJvbSAnQHBhcmNlbC93YXRjaGVyJztcbmltcG9ydCB7IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IgfSBmcm9tICcuL3NhbmRib3hfZXhlY3V0b3IuanMnO1xuaW1wb3J0IHtcbiAgQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICBTYW5kYm94LFxuICBTYW5kYm94RGVsZXRlT3B0aW9ucyxcbiAgU2FuZGJveEV2ZW50cyxcbiAgU2FuZGJveE9wdGlvbnMsXG59IGZyb20gJy4vc2FuZGJveC5qcyc7XG5pbXBvcnQgcGFyc2VHaXRJZ25vcmUgZnJvbSAncGFyc2UtZ2l0aWdub3JlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBfb3BlbiBmcm9tICdvcGVuJztcbi8vIEV2ZW50RW1pdHRlciBpcyBhIGNsYXNzIG5hbWUgYW5kIGV4cGVjdGVkIHRvIGhhdmUgUGFzY2FsQ2FzZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtcbiAgR2V0UGFyYW1ldGVyQ29tbWFuZCxcbiAgUGFyYW1ldGVyTm90Rm91bmQsXG4gIFNTTUNsaWVudCxcbiAgU1NNU2VydmljZUV4Y2VwdGlvbixcbn0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LXNzbSc7XG5pbXBvcnQge1xuICBBbXBsaWZ5UHJvbXB0ZXIsXG4gIExvZ0xldmVsLFxuICBQcmludGVyLFxuICBmb3JtYXQsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGktY29yZSc7XG5pbXBvcnQge1xuICBGaWxlc0NoYW5nZXNUcmFja2VyLFxuICBjcmVhdGVGaWxlc0NoYW5nZXNUcmFja2VyLFxufSBmcm9tICcuL2ZpbGVzX2NoYW5nZXNfdHJhY2tlci5qcyc7XG5pbXBvcnQge1xuICBBbXBsaWZ5RXJyb3IsXG4gIEFtcGxpZnlVc2VyRXJyb3IsXG4gIEJhY2tlbmRJZGVudGlmaWVyQ29udmVyc2lvbnMsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IExhbWJkYUZ1bmN0aW9uTG9nU3RyZWFtZXIgfSBmcm9tICcuL2xhbWJkYV9mdW5jdGlvbl9sb2dfc3RyZWFtZXIuanMnO1xuaW1wb3J0IHsgRU9MIH0gZnJvbSAnb3MnO1xuXG4vKipcbiAqIENESyBzdG9yZXMgYm9vdHN0cmFwIHZlcnNpb24gaW4gcGFyYW1ldGVyIHN0b3JlLiBFeGFtcGxlIHBhcmFtZXRlciBuYW1lIGxvb2tzIGxpa2UgL2Nkay1ib290c3RyYXAvPHF1YWxpZmllcj4vdmVyc2lvbi5cbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBxdWFsaWZpZXIgaXMgaG5iNjU5ZmRzLCBpLmUuIGRlZmF1bHQgcGFyYW1ldGVyIHBhdGggaXMgL2Nkay1ib290c3RyYXAvaG5iNjU5ZmRzL3ZlcnNpb24uXG4gKiBUaGUgZGVmYXVsdCBxdWFsaWZpZXIgaXMgaGFyZGNvZGVkIHZhbHVlIHdpdGhvdXQgYW55IHNpZ25pZmljYW5jZS5cbiAqIEFiaWxpdHkgdG8gcHJvdmlkZSBjdXN0b20gcXVhbGlmaWVyIGlzIGludGVuZGVkIGZvciBuYW1lIGlzb2xhdGlvbiBiZXR3ZWVuIGF1dG9tYXRlZCB0ZXN0cyBvZiB0aGUgQ0RLIGl0c2VsZi5cbiAqIEluIG9yZGVyIHRvIHVzZSBjdXN0b20gcXVhbGlmaWVyIGFsbCBzdGFjayBzeW50aGVzaXplcnMgbXVzdCBiZSBwcm9ncmFtbWF0aWNhbGx5IGNvbmZpZ3VyZWQgdG8gdXNlIGl0LlxuICogVGhhdCBtYWtlcyBib290c3RyYXBzIHdpdGggY3VzdG9tIHF1YWxpZmllciBpbmNvbXBhdGlibGUgd2l0aCBBbXBsaWZ5IEJhY2tlbmQgYW5kIHdlIHRyZWF0IHRoYXQgc2V0dXAgYXNcbiAqIG5vdCBib290c3RyYXBwZWQuXG4gKiBTZWU6IGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvdjIvZ3VpZGUvYm9vdHN0cmFwcGluZy5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBDREtfREVGQVVMVF9CT09UU1RSQVBfVkVSU0lPTl9QQVJBTUVURVJfTkFNRSA9XG4gIC8vIHN1cHByZXNzIHNwZWxsIGNoZWNrZXIsIGl0IGlzIHRyaWdnZXJlZCBieSBxdWFsaWZpZXIgdmFsdWUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzcGVsbGNoZWNrL3NwZWxsLWNoZWNrZXJcbiAgJy9jZGstYm9vdHN0cmFwL2huYjY1OWZkcy92ZXJzaW9uJztcbmV4cG9ydCBjb25zdCBDREtfTUlOX0JPT1RTVFJBUF9WRVJTSU9OID0gNjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMIGZvciBhIGdpdmVuIHJlZ2lvblxuICogQHBhcmFtIHJlZ2lvbiBBV1MgcmVnaW9uXG4gKiBAcmV0dXJucyBBbXBsaWZ5IENvbnNvbGUgYm9vdHN0cmFwIFVSTFxuICovXG5leHBvcnQgY29uc3QgZ2V0Qm9vdHN0cmFwVXJsID0gKHJlZ2lvbjogc3RyaW5nKSA9PlxuICBgaHR0cHM6Ly8ke3JlZ2lvbn0uY29uc29sZS5hd3MuYW1hem9uLmNvbS9hbXBsaWZ5L2NyZWF0ZS9ib290c3RyYXA/cmVnaW9uPSR7cmVnaW9ufWA7XG5cbi8qKlxuICogUnVucyBhIGZpbGUgd2F0Y2hlciBhbmQgZGVwbG95c1xuICovXG5leHBvcnQgY2xhc3MgRmlsZVdhdGNoaW5nU2FuZGJveCBleHRlbmRzIEV2ZW50RW1pdHRlciBpbXBsZW1lbnRzIFNhbmRib3gge1xuICBwcml2YXRlIHdhdGNoZXJTdWJzY3JpcHRpb246IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgX3N1YnNjcmliZT4+O1xuICBwcml2YXRlIG91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2ggPSBbJy5hbXBsaWZ5J107XG4gIHByaXZhdGUgZmlsZXNDaGFuZ2VzVHJhY2tlcjogRmlsZXNDaGFuZ2VzVHJhY2tlcjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdhdGNoZXIgcHJvY2VzcyBmb3IgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBiYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXI6IEJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4ZWN1dG9yOiBBbXBsaWZ5U2FuZGJveEV4ZWN1dG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc3NtQ2xpZW50OiBTU01DbGllbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmdW5jdGlvbnNMb2dTdHJlYW1lcjogTGFtYmRhRnVuY3Rpb25Mb2dTdHJlYW1lcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByaW50ZXI6IFByaW50ZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcGVuID0gX29wZW4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdWJzY3JpYmUgPSBfc3Vic2NyaWJlLFxuICApIHtcbiAgICBwcm9jZXNzLm9uY2UoJ1NJR0lOVCcsICgpID0+IHZvaWQgdGhpcy5zdG9wKCkpO1xuICAgIHByb2Nlc3Mub25jZSgnU0lHVEVSTScsICgpID0+IHZvaWQgdGhpcy5zdG9wKCkpO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbnRlcmNlcHRTdGRlcnIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgZW1pdChldmVudE5hbWU6IFNhbmRib3hFdmVudHMsIC4uLmFyZ3M6IHVua25vd25bXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIG92ZXJyaWRlIG9uKFxuICAgIGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cyxcbiAgICBsaXN0ZW5lcjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZCxcbiAgKTogdGhpcyB7XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBzdGFydCA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHdhdGNoRGlyID0gb3B0aW9ucy5kaXIgPz8gJy4vYW1wbGlmeSc7XG4gICAgY29uc3Qgd2F0Y2hGb3JDaGFuZ2VzID0gb3B0aW9ucy53YXRjaEZvckNoYW5nZXMgPz8gdHJ1ZTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyh3YXRjaERpcikpIHtcbiAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKCdQYXRoTm90Rm91bmRFcnJvcicsIHtcbiAgICAgICAgbWVzc2FnZTogYCR7d2F0Y2hEaXJ9IGRvZXMgbm90IGV4aXN0LmAsXG4gICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgJ01ha2Ugc3VyZSB5b3UgYXJlIHJ1bm5pbmcgdGhpcyBjb21tYW5kIGZyb20geW91ciBwcm9qZWN0IHJvb3QgZGlyZWN0b3J5LicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIgPSBhd2FpdCBjcmVhdGVGaWxlc0NoYW5nZXNUcmFja2VyKHdhdGNoRGlyKTtcbiAgICBjb25zdCBib290c3RyYXBwZWQgPSBhd2FpdCB0aGlzLmlzQm9vdHN0cmFwcGVkKCk7XG4gICAgLy8gZ2V0IHJlZ2lvbiBmcm9tIGFuIGF2YWlsYWJsZSBzZGsgY2xpZW50O1xuICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IHRoaXMuc3NtQ2xpZW50LmNvbmZpZy5yZWdpb24oKTtcbiAgICBpZiAoIWJvb3RzdHJhcHBlZCkge1xuICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgYFRoZSByZWdpb24gJHtmb3JtYXQuaGlnaGxpZ2h0KFxuICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgKX0gaGFzIG5vdCBiZWVuIGJvb3RzdHJhcHBlZC4gU2lnbiBpbiB0byB0aGUgQVdTIGNvbnNvbGUgYXMgYSBSb290IHVzZXIgb3IgQWRtaW4gdG8gY29tcGxldGUgdGhlIGJvb3RzdHJhcCBwcm9jZXNzLCB0aGVuIHJlc3RhcnQgdGhlIHNhbmRib3guJHtFT0x9SWYgdGhpcyBpcyBub3QgdGhlIHJlZ2lvbiB5b3UgYXJlIGV4cGVjdGluZyB0byBib290c3RyYXAsIGNoZWNrIGZvciBhbnkgQVdTIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IG1heSBiZSBzZXQgaW4geW91ciBzaGVsbCBvciB1c2UgJHtmb3JtYXQuY29tbWFuZChcbiAgICAgICAgICAnLS1wcm9maWxlIDxwcm9maWxlLW5hbWU+JyxcbiAgICAgICAgKX0gdG8gc3BlY2lmeSBhIHByb2ZpbGUgd2l0aCB0aGUgY29ycmVjdCByZWdpb24uYCxcbiAgICAgICk7XG4gICAgICBjb25zdCBib290c3RyYXBVcmwgPSBnZXRCb290c3RyYXBVcmwocmVnaW9uKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMub3Blbihib290c3RyYXBVcmwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBvcGVuaW5nIHRoZSBsaW5rIGZhaWxzIGZvciBhbnkgcmVhc29uIHdlIGZhbGwgYmFjayB0b1xuICAgICAgICAvLyBwcmludGluZyB0aGUgdXJsIGluIHRoZSBjb25zb2xlLlxuICAgICAgICAvLyBUaGlzIG1pZ2h0IGhhcHBlbjpcbiAgICAgICAgLy8gLSBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHNcbiAgICAgICAgLy8gLSBpZiB1c2VyIGRvZXMgbm90IGhhdmUgYW55IGFwcCB0byBvcGVuIFVSTFxuICAgICAgICAvLyAtIGlmIGJyb3dzZXIgY3Jhc2hlc1xuICAgICAgICBsZXQgbG9nRW50cnkgPSAnVW5hYmxlIHRvIG9wZW4gYm9vdHN0cmFwIHVybCc7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBsb2dFbnRyeSA9IGAke2xvZ0VudHJ5fSwgJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW50ZXIubG9nKGxvZ0VudHJ5LCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coYE9wZW4gJHtib290c3RyYXBVcmx9IGluIHRoZSBicm93c2VyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlnbm9yZWRQYXRocyA9IHRoaXMuZ2V0R2l0SWdub3JlZFBhdGhzKCk7XG4gICAgdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoID1cbiAgICAgIHRoaXMub3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaC5jb25jYXQoLi4uaWdub3JlZFBhdGhzKTtcblxuICAgIHRoaXMucHJpbnRlci5jbGVhckNvbnNvbGUoKTtcbiAgICBhd2FpdCB0aGlzLnByaW50U2FuZGJveE5hbWVJbmZvKG9wdGlvbnMuaWRlbnRpZmllcik7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuXG4gICAgLy8gLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICBmaWxlIGNoYW5nZWRcbiAgICAvLyB8ICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCBvcGVuIHwgICAgICAgICAgICAgICAgICAgICB8IGRlcGxveWluZyAgfCAgICAgICAgICAgICAgICAgICAgIHwgICBxdWV1ZWQgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLXxcbiAgICAvLyAtLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBsYXRjaDogJ29wZW4nIHwgJ2RlcGxveWluZycgfCAncXVldWVkJyA9ICdvcGVuJztcblxuICAgIGNvbnN0IGRlcGxveUFuZFdhdGNoID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcblxuICAgICAgLy8gU3RvcCBzdHJlYW1pbmcgdGhlIGxvZ3Mgc28gdGhhdCBkZXBsb3ltZW50IGxvZ3MgZG9uJ3QgZ2V0IG1peGVkIHVwXG4gICAgICB0aGlzLmZ1bmN0aW9uc0xvZ1N0cmVhbWVyLnN0b3BTdHJlYW1pbmdMb2dzKCk7XG5cbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKChsYXRjaCBhcyAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnKSA9PT0gJ3F1ZXVlZCcpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHJlYWxpemUgbGF0Y2ggY2FuIGNoYW5nZSBiZXR3ZWVuICdhd2FpdHMnIMKvXFxfKOODhClfL8KvLFxuICAgICAgICAvLyBhbmQgdGhpbmtzIHRoZSBhYm92ZSAnd2hpbGUnIGNvbmRpdGlvbiBpcyBhbHdheXMgJ2ZhbHNlJyB3aXRob3V0IHRoZSBjYXN0XG4gICAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICAgIHRoaXMucHJpbnRlci5jbGVhckNvbnNvbGUoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcmludFNhbmRib3hOYW1lSW5mbyhvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIFwiW1NhbmRib3hdIERldGVjdGVkIGZpbGUgY2hhbmdlcyB3aGlsZSBwcmV2aW91cyBkZXBsb3ltZW50IHdhcyBpbiBwcm9ncmVzcy4gSW52b2tpbmcgJ3NhbmRib3gnIGFnYWluXCIsXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGF0Y2ggPSAnb3Blbic7XG5cbiAgICAgIC8vIElkbGUgc3RhdGUsIGxldCBjdXN0b21lcnMga25vdyBhbmQgc3RhcnQgc3RyZWFtaW5nIGZ1bmN0aW9uIGxvZ3NcbiAgICAgIHRoaXMuZW1pdFdhdGNoaW5nKCk7XG4gICAgICBhd2FpdCB0aGlzLmZ1bmN0aW9uc0xvZ1N0cmVhbWVyLnN0YXJ0U3RyZWFtaW5nTG9ncyhcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgICAgb3B0aW9ucy5mdW5jdGlvblN0cmVhbWluZ09wdGlvbnMsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKHdhdGNoRm9yQ2hhbmdlcykge1xuICAgICAgdGhpcy53YXRjaGVyU3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIHdhdGNoRGlyLFxuICAgICAgICBhc3luYyAoXywgZXZlbnRzKSA9PiB7XG4gICAgICAgICAgLy8gTG9nIGFuZCB0cmFjayBmaWxlIGNoYW5nZXMuXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBldmVudHMubWFwKGFzeW5jICh7IHR5cGU6IGV2ZW50TmFtZSwgcGF0aDogZmlsZVBhdGggfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmZpbGVzQ2hhbmdlc1RyYWNrZXIudHJhY2tGaWxlQ2hhbmdlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50ZXIuY2xlYXJDb25zb2xlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmludFNhbmRib3hOYW1lSW5mbygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgICAgYFtTYW5kYm94XSBUcmlnZ2VyZWQgZHVlIHRvIGEgZmlsZSAke2V2ZW50TmFtZX0gZXZlbnQ6ICR7cGF0aC5yZWxhdGl2ZShcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3MuY3dkKCksXG4gICAgICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsYXRjaCA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGxhdGNoIGlzIGVpdGhlciAnZGVwbG95aW5nJyBvciAncXVldWVkJ1xuICAgICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgICdbU2FuZGJveF0gUHJldmlvdXMgZGVwbG95bWVudCBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gJyArXG4gICAgICAgICAgICAgICAgJ1dpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlnbm9yZTogdGhpcy5vdXRwdXRGaWxlc0V4Y2x1ZGVkRnJvbVdhdGNoLmNvbmNhdChcbiAgICAgICAgICAgIC4uLihvcHRpb25zLmV4Y2x1ZGUgPz8gW10pLFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgLy8gU3RhcnQgdGhlIGZpcnN0IGZ1bGwgZGVwbG95bWVudCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgZmlsZSBjaGFuZ2VcbiAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhgW1NhbmRib3hdIFNodXR0aW5nIGRvd25gLCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgdGhpcy5mdW5jdGlvbnNMb2dTdHJlYW1lcj8uc3RvcFN0cmVhbWluZ0xvZ3MoKTtcbiAgICAvLyBjYW4gYmUgdW5kZWZpbmVkIGlmIGNvbW1hbmQgZXhpdHMgYmVmb3JlIHN1YnNjcmlwdGlvblxuICAgIGF3YWl0IHRoaXMud2F0Y2hlclN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIGRlbGV0ZSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94RGVsZXRlT3B0aW9ucykgPT4ge1xuICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAnW1NhbmRib3hdIERlbGV0aW5nIGFsbCB0aGUgcmVzb3VyY2VzIGluIHRoZSBzYW5kYm94IGVudmlyb25tZW50Li4uJyxcbiAgICApO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0b3IuZGVzdHJveShcbiAgICAgIGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKG9wdGlvbnMuaWRlbnRpZmllciksXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZWxldGlvbicpO1xuICAgIHRoaXMucHJpbnRlci5sb2coJ1tTYW5kYm94XSBGaW5pc2hlZCBkZWxldGluZy4nKTtcbiAgfTtcblxuICBwcml2YXRlIHNob3VsZFZhbGlkYXRlQXBwU291cmNlcyA9ICgpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci5nZXRBbmRSZXNldFNuYXBzaG90KCk7XG4gICAgLy8gaWYgemVybyBmaWxlcyBjaGFuZ2VkIHRoaXMgaW5kaWNhdGVzIGluaXRpYWwgZGVwbG95bWVudFxuICAgIGNvbnN0IHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgPVxuICAgICAgc25hcHNob3QuaGFkVHlwZVNjcmlwdEZpbGVzQXRTdGFydCAmJlxuICAgICAgIXNuYXBzaG90LmRpZEFueUZpbGVDaGFuZ2VTaW5jZVN0YXJ0O1xuICAgIHJldHVybiAoXG4gICAgICBzaG91bGRWYWxpZGF0ZU9uQ29sZFN0YXJ0IHx8XG4gICAgICBzbmFwc2hvdC5kaWRBbnlUeXBlU2NyaXB0RmlsZUNoYW5nZVNpbmNlTGFzdFNuYXBzaG90XG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGRlcGxveSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXBsb3lSZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlcGxveShcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcGFzcyB0aGlzIGFzIGNhbGxiYWNrIHNvIHRoYXQgZGVib3VuY2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVzZXQgdHJhY2tlciBwcmVtYXR1cmVseVxuICAgICAgICB0aGlzLnNob3VsZFZhbGlkYXRlQXBwU291cmNlcyxcbiAgICAgICk7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKCdbU2FuZGJveF0gRGVwbG95bWVudCBzdWNjZXNzZnVsJywgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgdGhpcy5lbWl0KCdzdWNjZXNzZnVsRGVwbG95bWVudCcsIGRlcGxveVJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFByaW50IGEgbWVhbmluZ2Z1bCBtZXNzYWdlXG4gICAgICB0aGlzLnByaW50ZXIubG9nKGZvcm1hdC5lcnJvcihlcnJvciksIExvZ0xldmVsLkVSUk9SKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkRGVwbG95bWVudCcsIGVycm9yKTtcblxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIGJlY2F1c2Ugb2YgYSBub24tYWxsb3dlZCBkZXN0cnVjdGl2ZSBjaGFuZ2Ugc3VjaCBhc1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWNvZ25pdG8tdXNlcnBvb2wuaHRtbCNjZm4tY29nbml0by11c2VycG9vbC1hbGlhc2F0dHJpYnV0ZXNcbiAgICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IG9yIHJldmVydCB0aGUgY2hhbmdlXG4gICAgICBpZiAoXG4gICAgICAgIEFtcGxpZnlFcnJvci5pc0FtcGxpZnlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gJ0NGTlVwZGF0ZU5vdFN1cHBvcnRlZEVycm9yJ1xuICAgICAgKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIGRvIG5vdCBwcm9wYWdhdGUgYW5kIGxldCB0aGUgc2FuZGJveCBjb250aW51ZSB0byBydW5cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZXNldCA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlKHsgaWRlbnRpZmllcjogb3B0aW9ucy5pZGVudGlmaWVyIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEp1c3QgYSBzaG9ydGhhbmQgY29uc29sZSBsb2cgdG8gaW5kaWNhdGUgd2hlbmV2ZXIgd2F0Y2hlciBpcyBnb2luZyBpZGxlXG4gICAqL1xuICBwcml2YXRlIGVtaXRXYXRjaGluZyA9ICgpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKGBbU2FuZGJveF0gV2F0Y2hpbmcgZm9yIGZpbGUgY2hhbmdlcy4uLmApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyBhbmQgcGFyc2VzIC5naXRpZ25vcmUgZmlsZSBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBwYXRoc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRHaXRJZ25vcmVkUGF0aHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2l0SWdub3JlRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJy5naXRpZ25vcmUnKTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhnaXRJZ25vcmVGaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUdpdElnbm9yZVxuICAgICAgICAucGFyc2UoZ2l0SWdub3JlRmlsZVBhdGgpXG4gICAgICAgIC5wYXR0ZXJucy5tYXAoKHBhdHRlcm46IHN0cmluZykgPT5cbiAgICAgICAgICBwYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdHRlcm4uc3Vic3RyaW5nKDEpIDogcGF0dGVybixcbiAgICAgICAgKVxuICAgICAgICAuZmlsdGVyKChwYXR0ZXJuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAocGF0dGVybi5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgIGBbU2FuZGJveF0gUGF0dGVybiAke3BhdHRlcm59IGZvdW5kIGluIC5naXRpZ25vcmUuIFwiJHtwYXR0ZXJuLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICApfVwiIHdpbGwgbm90IGJlIHdhdGNoZWQgaWYgb3RoZXIgcGF0dGVybnMgaW4gLmdpdGlnbm9yZSBhcmUgZXhjbHVkaW5nIGl0LmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZCB3aXRoID49IG1pbiB2ZXJzaW9uIHVzaW5nIENESyBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXJcbiAgICogc3RvcmVkIGluIHBhcmFtZXRlciBzdG9yZS5cbiAgICogQHJldHVybnMgQSBCb29sZWFuIHRoYXQgcmVwcmVzZW50cyBpZiByZWdpb24gaGFzIGJlZW4gYm9vdHN0cmFwcGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Jvb3RzdHJhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBQYXJhbWV0ZXI6IHBhcmFtZXRlciB9ID0gYXdhaXQgdGhpcy5zc21DbGllbnQuc2VuZChcbiAgICAgICAgbmV3IEdldFBhcmFtZXRlckNvbW1hbmQoe1xuICAgICAgICAgIE5hbWU6IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXI/LlZhbHVlO1xuICAgICAgaWYgKFxuICAgICAgICAhYm9vdHN0cmFwVmVyc2lvbiB8fFxuICAgICAgICBOdW1iZXIoYm9vdHN0cmFwVmVyc2lvbikgPCBDREtfTUlOX0JPT1RTVFJBUF9WRVJTSU9OXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJhbWV0ZXJOb3RGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGUgaW5zdGFuY2VvZiBTU01TZXJ2aWNlRXhjZXB0aW9uICYmXG4gICAgICAgIFtcbiAgICAgICAgICAnVW5yZWNvZ25pemVkQ2xpZW50RXhjZXB0aW9uJyxcbiAgICAgICAgICAnQWNjZXNzRGVuaWVkRXhjZXB0aW9uJyxcbiAgICAgICAgICAnTm90QXV0aG9yaXplZCcsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicsXG4gICAgICAgICAgJ0V4cGlyZWRUb2tlbicsXG4gICAgICAgICAgJ0ludmFsaWRTaWduYXR1cmVFeGNlcHRpb24nLFxuICAgICAgICBdLmluY2x1ZGVzKGUubmFtZSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcihcbiAgICAgICAgICAnU1NNQ3JlZGVudGlhbHNFcnJvcicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZS5uYW1lfTogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIHJlc29sdXRpb246XG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgeW91ciBBV1MgY3JlZGVudGlhbHMgYXJlIHNldCB1cCBjb3JyZWN0bHkgYW5kIGhhdmUgcGVybWlzc2lvbnMgdG8gY2FsbCBTU006R2V0UGFyYW1ldGVyJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGUsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGFyZSB1bmFibGUgdG8gcmV0cmlldmUgYm9vdHN0cmFwIHZlcnNpb24gcGFyYW1ldGVyIGR1ZSB0byBvdGhlciByZWFzb25zLCB3ZSBmYWlsIGZhc3QuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVVuc3VwcG9ydGVkRGVzdHJ1Y3RpdmVDaGFuZ2VzID0gYXN5bmMgKFxuICAgIG9wdGlvbnM6IFNhbmRib3hPcHRpb25zLFxuICApID0+IHtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuZXJyb3IoXG4gICAgICAgICdbU2FuZGJveF0gV2UgY2Fubm90IGRlcGxveSB5b3VyIG5ldyBjaGFuZ2VzLiBZb3UgY2FuIGVpdGhlciByZXZlcnQgdGhlbSBvciByZWNyZWF0ZSB5b3VyIHNhbmRib3ggd2l0aCB0aGUgbmV3IGNoYW5nZXMgKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpJyxcbiAgICAgICksXG4gICAgKTtcbiAgICAvLyBvZmZlciB0byByZWNyZWF0ZSB0aGUgc2FuZGJveCB3aXRoIG5ldyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgYW5zd2VyID0gYXdhaXQgQW1wbGlmeVByb21wdGVyLnllc09yTm8oe1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ1dvdWxkIHlvdSBsaWtlIHRvIHJlY3JlYXRlIHlvdXIgc2FuZGJveCAoZGVsZXRpbmcgYWxsIHVzZXIgZGF0YSk/JyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgfSk7XG4gICAgaWYgKGFuc3dlcikge1xuICAgICAgYXdhaXQgdGhpcy5zdG9wKCk7XG4gICAgICBhd2FpdCB0aGlzLnJlc2V0KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBlbHNlIGxldCB0aGUgc2FuZGJveCBjb250aW51ZSBzbyBjdXN0b21lcnMgY2FuIHJldmVydCB0aGVpciBjaGFuZ2VzXG4gIH07XG5cbiAgcHJpdmF0ZSBwcmludFNhbmRib3hOYW1lSW5mbyA9IGFzeW5jIChzYW5kYm94SWRlbnRpZmllcj86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNhbmRib3hCYWNrZW5kSWQgPVxuICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIoc2FuZGJveElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHN0YWNrTmFtZSA9XG4gICAgICBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHNhbmRib3hCYWNrZW5kSWQpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IHRoaXMuc3NtQ2xpZW50LmNvbmZpZy5yZWdpb24oKTtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuaW5kZW50KGZvcm1hdC5oaWdobGlnaHQoZm9ybWF0LmJvbGQoJ1xcbkFtcGxpZnkgU2FuZGJveFxcbicpKSksXG4gICAgKTtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdJZGVudGlmaWVyOicpfSBcXHQke3NhbmRib3hCYWNrZW5kSWQubmFtZX1gKSxcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5wcmludChcbiAgICAgIGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ1N0YWNrOicpfSBcXHQke3N0YWNrTmFtZX1gKSxcbiAgICApO1xuICAgIHRoaXMucHJpbnRlci5wcmludChmb3JtYXQuaW5kZW50KGAke2Zvcm1hdC5ib2xkKCdSZWdpb246Jyl9IFxcdCR7cmVnaW9ufWApKTtcbiAgICBpZiAoIXNhbmRib3hJZGVudGlmaWVyKSB7XG4gICAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICAgIGAke2Zvcm1hdC5pbmRlbnQoXG4gICAgICAgICAgZm9ybWF0LmRpbSgnXFxuVG8gc3BlY2lmeSBhIGRpZmZlcmVudCBzYW5kYm94IGlkZW50aWZpZXIsIHVzZSAnKSxcbiAgICAgICAgKX0ke2Zvcm1hdC5ib2xkKCctLWlkZW50aWZpZXInKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wcmludGVyLnByaW50TmV3TGluZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYWNrIHRvIHN1cHByZXNzIGNlcnRhaW4gc3RkZXJyIG1lc3NhZ2VzIHVudGlsIGF3cy1jZGsgY29uc3RydWN0c1xuICAgKiBjYW4gdXNlIHRoZSB0b29sa2l0J3MgSW9Ib3N0IHRvIGRlbGl2ZXIgbWVzc2FnZXMuXG4gICAqIFNlZSB0cmFja2luZyBpdGVtcyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGstY2xpL2lzc3Vlcy8xNThcbiAgICpcbiAgICogUmVzdCBvZiB0aGUgc3RkZXJyIG1lc3NhZ2VzIGFyZSByZXJvdXRlZCB0byBvdXIgcHJpbnRlciBzbyB0aGF0IHRoZXlcbiAgICogZG9uJ3QgZ2V0IGludGVybWluZ2xlZCB3aXRoIHNwaW5uZXJzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcmNlcHRTdGRlcnIgPSAoKSA9PiB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUgPSAoY2h1bmspID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhWydCdW5kbGluZyBhc3NldCddLnNvbWUoKHByb2hpYml0ZWRTdHJpbmdzKSA9PlxuICAgICAgICAgIGNodW5rLmluY2x1ZGVzKHByb2hpYml0ZWRTdHJpbmdzKSxcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogY2h1bmsudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH07XG59XG4iXX0=